// Decompiled by DJ v2.9.9.60 Copyright 2000 Atanas Neshkov  Date: 21/10/02 16:12:48
// Home Page : http://members.fortunecity.com/neshkov/dj.html  - Check often for new version!
// Decompiler options: packimports(3) 

package bsh.util;

import bsh.*;
import com.ibm.bsf.*;
import com.ibm.bsf.util.BSFEngineImpl;
import java.util.Vector;

public class BeanShellBSFEngine extends BSFEngineImpl
{

    public BeanShellBSFEngine()
    {
    }

    public void initialize(BSFManager bsfmanager, String s, Vector vector)
        throws BSFException
    {
        super.initialize(bsfmanager, s, vector);
        interpreter = new Interpreter();
        try
        {
            interpreter.set("bsf", bsfmanager);
        }
        catch(EvalError evalerror)
        {
            throw new BSFException("bsh internal error: " + evalerror.toString());
        }
        for(int i = 0; i < vector.size(); i++)
        {
            BSFDeclaredBean bsfdeclaredbean = (BSFDeclaredBean)vector.get(i);
            declareBean(bsfdeclaredbean);
        }

    }

    public void setDebug(boolean flag)
    {
        BeanShellBSFEngine _tmp = this;
        Interpreter.DEBUG = flag;
    }

    public Object call(Object obj, String s, Object aobj[])
        throws BSFException
    {
        if(obj == null)
            try
            {
                obj = interpreter.get("global");
            }
            catch(EvalError evalerror)
            {
                throw new BSFException("bsh internal error: " + evalerror.toString());
            }
        if(obj instanceof This)
            try
            {
                return ((This)obj).invokeMethod(s, aobj);
            }
            catch(InterpreterError interpretererror)
            {
                throw new BSFException("BeanShell interpreter internal error: " + interpretererror);
            }
            catch(TargetError targeterror)
            {
                throw new BSFException("The application script threw an exception: " + targeterror.getTarget());
            }
            catch(EvalError evalerror1)
            {
                throw new BSFException("BeanShell script error: " + evalerror1);
            }
        else
            throw new BSFException("Cannot invoke method: " + s + ". Object: " + obj + " is not a BeanShell scripted object.");
    }

    public Object apply(String s, int i, int j, Object obj, Vector vector, Vector vector1)
        throws BSFException
    {
        if(vector.size() != vector1.size())
            throw new BSFException("number of params/names mismatch");
        if(!(obj instanceof String))
            throw new BSFException("apply: functino body must be a string");
        String as[] = new String[vector.size()];
        vector.copyInto(as);
        String as1[] = new String[vector1.size()];
        vector1.copyInto(as1);
        try
        {
            if(!installedApplyMethod)
            {
                interpreter.eval("_bsfApply( _bsfNames, _bsfArgs, _bsfText ) {for(i=0;i<_bsfNames.length;i++)this.namespace.setVariable(_bsfNames[i], _bsfArgs[i]);return this.interpreter.eval(_bsfText, this.namespace);}");
                installedApplyMethod = true;
            }
            This this1 = (This)interpreter.get("global");
            return this1.invokeMethod("_bsfApply", new Object[] {
                as, as1, (String)obj
            });
        }
        catch(InterpreterError interpretererror)
        {
            throw new BSFException("BeanShell interpreter internal error: " + interpretererror + sourceInfo(s, i, j));
        }
        catch(TargetError targeterror)
        {
            throw new BSFException("The application script threw an exception: " + targeterror.getTarget() + sourceInfo(s, i, j));
        }
        catch(EvalError evalerror)
        {
            throw new BSFException("BeanShell script error: " + evalerror + sourceInfo(s, i, j));
        }
    }

    public Object eval(String s, int i, int j, Object obj)
        throws BSFException
    {
        if(!(obj instanceof String))
            throw new BSFException("BeanShell expression must be a string");
        try
        {
            return interpreter.eval((String)obj);
        }
        catch(InterpreterError interpretererror)
        {
            throw new BSFException("BeanShell interpreter internal error: " + interpretererror + sourceInfo(s, i, j));
        }
        catch(TargetError targeterror)
        {
            throw new BSFException("The application script threw an exception: " + targeterror.getTarget() + sourceInfo(s, i, j));
        }
        catch(EvalError evalerror)
        {
            throw new BSFException("BeanShell script error: " + evalerror + sourceInfo(s, i, j));
        }
    }

    public void exec(String s, int i, int j, Object obj)
        throws BSFException
    {
        eval(s, i, j, obj);
    }

    public void declareBean(BSFDeclaredBean bsfdeclaredbean)
        throws BSFException
    {
        try
        {
            interpreter.set(bsfdeclaredbean.name, bsfdeclaredbean.bean);
        }
        catch(EvalError evalerror)
        {
            throw new BSFException("error declaring bean: " + bsfdeclaredbean.name + " : " + evalerror.toString());
        }
    }

    public void undeclareBean(BSFDeclaredBean bsfdeclaredbean)
        throws BSFException
    {
        try
        {
            interpreter.unset(bsfdeclaredbean.name);
        }
        catch(EvalError evalerror)
        {
            throw new BSFException("bsh internal error: " + evalerror.toString());
        }
    }

    public void terminate()
    {
    }

    private String sourceInfo(String s, int i, int j)
    {
        return " BSF info: " + s + " at line: " + i + " column: columnNo";
    }

    Interpreter interpreter;
    boolean installedApplyMethod;
    static final String bsfApplyMethod = "_bsfApply( _bsfNames, _bsfArgs, _bsfText ) {for(i=0;i<_bsfNames.length;i++)this.namespace.setVariable(_bsfNames[i], _bsfArgs[i]);return this.interpreter.eval(_bsfText, this.namespace);}";
}