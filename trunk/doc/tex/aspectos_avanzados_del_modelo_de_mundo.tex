\chapter {Aspectos avanzados del modelo de mundo}

Con lo que se ha visto en las secciones 1 y 2 de esta documentación, es más
que suficiente para crear aventuras de texto funcionales: hemos visto cómo
construir un mundo con habitaciones y cosas conectadas entre sí, cómo
responder a órdenes del jugador, manipular las entidades (comprobando si un
personaje tiene una cosa, quitando y poniendo elementos en el mundo,
moviendo objetos, etc.) y guardar y manejar datos mediante las propiedades
y relaciones. Hemos visto también cómo se programa en BeanShell, incluyendo
todo lo esencial para crear código que funcione: métodos, estructuras
condicionales, bucles, manejo de arrays y listas, e interpretación de los
mensajes de error del intérprete.

Una vez visto esto, como autor de AGE y de este documento recomiendo que os
pongáis manos a la obra y creéis alguna aventura sencillita para ponerlo a
prueba y cogerle el truco a la herramienta. Y hecho esto, podéis profundizar
más en ésta y las siguientes secciones.

En la presente sección cubriremos algunos aspectos más avanzados del modelo
de mundo que no hemos visto por anterioridad, y que sirven sobre todo para
facilitar la inclusión de objetos y comportamientos que son comunes en las
aventuras y que; aunque se podrían programar ``a mano'' con lo que hemos
visto hasta ahora, resulta mucho más cómodo y rápido tener predefinidos:
por ejemplo, el soporte para puertas y objetos abribles y cerrables,
descripciones dinámicas, armas, etc.

Cada parte de esta sección cubre una funcionalidad concreta y cada una de
esas partes se pueden leer independientemente de las demás, de forma que
puedes consultar directamente la funcionalidad que te haga falta.

\section{Descripciones y nombres dinámicos}

Un buen juego no se mantiene siempre estático a lo largo de las partidas;
sino que cambia con el tiempo. AGE proporciona un sencillo mecanismo de
\textit{descripciones y nombres dinámicos} que facilita que las
descripciones y nombres de habitaciones, cosas y personajes puedan cambiar
según las circunstancias. Con esto, se pueden conseguir efectos como:

\begin{itemize}
\item {Que la descripción de una calle cambie según si es de día o de
noche,}
\item {Que cambie según el humor del personaje (lo que para uno es un día
alegre para otro podría ser un día horrible),}
\item {Que la descripción y/o nombre de una cosa cambie según su estado (la
misma espada a lo largo de una aventura puede estar limpia o manchada de
sangre, o tal vez oxidada),}
\item {Que el nombre de un personaje se muestre distinta según si un
jugador lo conoce o no (el jugador podría ver a un personaje como ``un
hombre de mediana edad'' cuando no sabe quién es, y una vez que se lo han
presentado verlo como ``Benito''),}
\item {Que el nombre o descripción de una cosa se muestre distinto según
los conocimientos de un jugador (lo que para un bárbaro iletrado es ``un
libro muy grande'', para un mago podría ser ``un tomo sobre magia de
combate'').}
\end{itemize}

Todo esto se consigue de forma sencilla especificando condiciones en las
áreas de nombres y descripciones de PUCK.

\subsection{Descripciones dinámicas}

Las descripciones dinámicas se pueden definir tanto para habitaciones como
para cosas y personajes. Esto se hace introduciendo una lista de
condiciones y descripciones en el cuadro ``Descripciones'' de la ficha
``General'' de estas entidades. Para añadir un elemento a esta lista,
introducimos una condición en el campo ``Condición'', la descripción
asociada en el campo ``Descripción'', y pulsamos Añadir. La condición que
introduzcamos en el campo ``Condición'' es un pedazo de código BeanShell
con las siguientes características:

\begin{itemize}
\item {Tiene que ser una expresión booleana, es decir, un trozo de código
simple (sin estructuras \textsf{if}, bucles ni puntos y coma; aunque sí
puede tener llamadas a métodos, operaciones, etc.) y que devuelva un valor
de tipo \textsf{boolean} (\textsf{true} o \textsf{false}). Dicho con otras
palabras, la condición puede ser cualquier trozo de código que pudiese ir
como condición de un \textsf{if}.}
\item {Podemos usar la variable \textsf{self} para referirnos al objeto en
que estamos definiendo la descripción, y la variable \textsf{world} para
referirnos al mundo, exactamente igual que en los métodos definidos
mediante BeanShell.}
\item {Adicionalmente, en estos campos de condición tenemos una variable
especial \textsf{viewer} que podemos utilizar para referirnos al jugador o
criatura que está mirando aquello que describimos. Esto se puede usar, por
ejemplo, en los ejemplos de aplicación que proponíamos antes para mostrar
diferentes descripciones a un jugador según su humor o según sus
conocimientos sobre la entidad.}
\end{itemize}

Así, ejemplos de posibles condiciones podrían ser:

\textsf{get(self,"oxidada")} -- esta descripción es sólo para si la cosa
que describimos (una espada, por ejemplo) está oxidada.

\textsf{!get(self,"oxidada")} -- lo contrario, se muestra sólo si la espada
no está oxidada.

\textsf{get(viewer,"conoce",self)} -- descripción que se muestra sólo si el
jugador que está mirando al personaje que describimos ya lo conoce (hecho
descrito por una relación ``conoce'').

\textsf{get(viewer,"humor") > 5} -- mostrar esa descripción sólo si el humor
del jugador que mira es mayor que 5 (si hemos definido el humor como una
propiedad de tipo int que toma valores de 0 a 10, por ejemplo, esto sería
una descripción que sólo se ve si estás de buen humor).

Cuando un jugador mire la entidad cuya descripción dinámica hemos definido
de esta manera, la descripción que se mostrará al jugador será la
concatenación de todas aquellas descripciones de la lista cuyas condiciones
asociadas se cumplan. Nótese que esto quiere decir que podemos construir
descripciones dinámicas ``a trozos'', dividiéndolas en partes con distintas
condiciones. Un ejemplo de esto sería el siguiente, en una habitación:

Condición: en blanco (``siempre''), descripción: Te encuentras en una
habitación de hotel.

Condición: \textsf{get(self,"luzEncendida")}, descripción: Es una habitación
pequeña y sencilla: sólo tiene una cama, un armario y una pequeña mesilla
de noche.

Condición: \textsf{!get(self,"luzEncendida")}, descripción: La luz está
apagada, y la escasa luz de las farolas que entra desde la ventana apenas
te deja intuir la silueta de una cama.

Condición: \verb|( get(self,"luzEncendida") && get(viewer,"humor") > 5 )|,
descripción: En una de las paredes hay un cuadro de dudoso gusto que
muestra un hombre a caballo.

Condición: \verb|( get(self,"luzEncendida") && get(viewer,"humor") <= 5 )|,
descripción: En una de las paredes hay un cuadro de un hombre a caballo,
tan horriblemente pintado que dan ganas de tirarlo por la ventana.

Así, is por ejemplo la luz estuviera encendida y el humor del jugador fuese
2, se le mostraría esta descripción de la habitación:

\textsf{Te encuentras en una habitación de hotel. Es una habitación pequeña
y sencilla: sólo tiene una cama, un armario y una pequeña mesilla de noche.
En una de las paredes hay un cuadro de un hombre a caballo, tan
horriblemente pintado que dan ganas de tirarlo por la ventana.}

Mientras que si la luz estuviese apagada, se mostraría

\textsf{Te encuentras en una habitación de hotel. La luz está apagada, y la
escasa luz de las farolas que entra desde la ventana apenas te deja intuir
la silueta de una cama.}

\subsection{Nombres dinámicos}

El mismo mecanismo que hemos explicado para las descripciones de
habitaciones, cosas y criaturas se aplica también a los nombres singulares
y plurales para mostrar de las cosas y criaturas. Las características que
deben cumplir las condiciones en este caso son las mismas que para las
descripciones, incluida la posibilidad de utilizar la variable especial
\textsf{viewer}.

Hay, sin embargo, una diferencia: los nombres dinámicos que se muestran a
los jugadores no se construyen ``a trozos'' como las descripciones, ya que
eso no tendría mucha utilidad, sino que simplemente se muestra el primer
nombre cuya condición se cumpla. Si hay más de un nombre cuya condición se
cumple, el resto se ignorarán.

\section{Cosas abribles y cerrables}

En muchos juegos basados en texto aparecen objetos que pueden abrirse y
cerrarse. Puertas, ventanas, baúles, cajas fuertes o maletas son ejemplos
típicos de objetos así. El AGE proporciona soporte para crear fácilmente
tales objetos, que los jugadores y criaturas pueden abrir y cerrar con o
sin necesitar para ello una llave, según cómo están configurados.

Grosso modo, el sistema de cosas abribles y cerrables de AGE funciona de la
siguiente manera:

\begin{itemize}
\item {En un momento dado, una cosa puede estar abierta o cerrada.}
\item {Además, una cosa que está cerrada puede estar cerrada con llave o no.}
\item {La orden \textsf{cerrar cosa} introducida por un jugador sirve para
cerrar algo que está abierto, la orden \textsf{abrir cosa} para abrir algo
que está cerrado. Es posible definir condiciones para que estos comandos
funcionen o no según el criterio que se quiera (por ejemplo, una puerta que
no se pueda abrir sin más porque está atrancada, etc.)}
\item {La orden \textsf{abrir cosa con llave} introducida por un jugador
sirve para quitar el cerrojo a algo que está cerrado con llave, y la orden
\textsf{cerrar cosa con llave} hace lo contrario. AGE permite definir qué
cosa del juego es la llave de cada cosa abrible/cerrable con llave. Asimismo,
también se pueden definir condiciones para que estos comandos funcionen o no
(además de la condición implícita de tener la llave).}
\item {En cada cosa, se puede marcar individual e independientemente si es
abrible, cerrable, abrible con llave y cerrable con llave. Esto nos permite
la flexibilidad de definir, por ejemplo, algo que se puede abrir pero no se
puede volver a cerrar una vez abierto; o también de obviar el sistema de
llaves si no las necesitamos en nuestro juego.}
\item {Se pueden crear puertas especificando que una cosa es la puerta
asociada a un camino, de forma que no se dejará pasar al jugador por ella
cuando esté cerrada.}
\item {Si una cosa cerrada es un contenedor, no permitirá a los jugadores
manipular lo que haya en su interior hasta que se abra.}
\end{itemize}

\subsection{Definiendo cosas abribles y cerrables}

Para definir una cosa abrible y/o cerrable en nuestro mundo de AGE, creamos
una cosa en el PUCK de forma normal (rellenando su nombre único, nombres de
referencia y demás campos útiles como de costumbre) y a continuación vamos
a la ficha llamada ``Abrir/Cerrar'' de su panel de objeto.

Lo primero que vemos en esta ficha son cuatro cuadros que podemos marcar
para determinar si la cosa es ``Abrible'', ``Cerrable'', ``Cerrable con
llave'' y ``Abrible con llave'', respectivamente. Así, por ejemplo, si
queremos crear una caja que se pueda abrir y cerrar pero que no necesite
una llave para ello, marcaremos los dos primeros cuadros. Si lo que
queremos es una puerta que además tenga una llave que tenga una cerradura
con llave, los marcaremos todos. Es perfectamente posible marcar cualquier
combinación de acciones posibles: por ejemplo, un plástico donde venga
envuelto un CD de música podría modelarse como un objeto abrible, pero no
cerrable (una vez que lo rompemos, no podemos devolverlo a su estado
original).

A continuación vemos cuatro formularios para textos dinámicos asociadas a
cada una de las cuatro acciones: abrir, cerrar, cerrar con llave y abrir
con llave. Como es lógico, sólo tendremos que cubrir los campos
correspondientes a las acciones que hayamos marcado como posibles en los
cuadros anteriores (por ejemplo, a abrir y cerrar en el caso de la caja).

El formulario de estos textos dinámicos es análogo al de las descripciones
y nombres dinámicos; pero con un añadido: además de especificar una
condición y un texto asociado, también tenemos la posibilidad de marcar o
no una casilla llamada ``Con éxito''. Esta casilla determina si la acción
correspondiente (abrir, cerrar, etc.) se llevará a cabo con éxito o no, en
el caso de que la condición asociada sea cierta. De este modo, en el
formulario de ``Texto al abrir'' no sólo estamos definiendo el texto en sí,
sino también las condiciones que son necesarias para que la cosa se pueda
abrir; y lo análogo para ``Texto al cerrar'' y el resto de formularios
similares.

Más en detalle, cuando un jugador teclea una orden abrir sobre una cosa,
AGE hace lo siguiente:

\begin{enumerate}
\item {Si la cosa no está marcada como ``Abrible'', se le dice al jugador
que no tiene sentido abrir eso.}
\item {Si la cosa sí está marcada como ``Abrible'', se recorren las entradas
del formulario ``Texto al abrir'' comprobando si se cumple la condición de
alguna de ellas. En el caso de que se cumpla la condición de una de ellas:
	\begin{enumerate}
	\item {Si esa entrada del formulario era de ``Éxito'' (se marcó la
	casilla ``Con éxito''), entonces se muestra el mensaje correspondiente, y
	la cosa se abre.}
	\item {Si esa entrada del formulario era sin éxito (no se marcó la casilla
	``Con éxito''), entonces se muestra el mensaje correspondiente; pero no
	se hace ningún cambio en el estado de la cosa.}
	\end{enumerate}
}
\end{enumerate}

El funcionamiento de cerrar es análogo, trabajando en cada caso con la
casilla y el formulario correspondientes a esa orden.

Las condiciones que se pueden teclear en estos formularios son expresiones
booleanas en BeanShell, exactamente igual que para las descripciones y
nombres dinámicos. A menudo, para escribir estas condiciones necesitaremos
tener una forma de saber si una cosa está abierta o cerrada, y si está
cerrada con llave o no. Para ello, podemos usar los siguientes métodos de
la clase \textsf{Item}:

\begin{lstlisting}
/*clase Item*/ boolean isOpen ( )
/*clase Item*/ boolean isClosed ( )
/*clase Item*/ boolean isLocked ( )
/*clase Item*/ boolean isUnlocked ( )
\end{lstlisting}

Estos métodos nos permiten comprobar el estado de las cosas
abribles/cerrables: son métodos booleanos que devuelven \textsf{true} si la
cosa sobre la que los ejecutamos está abierta, cerrada, cerrada con llave o
no cerrada con llave, respectivamente; y false de lo contrario.

De este modo, por ejemplo, podemos definir una caja que se abra y se cierre
marcándola como abrible y cerrable en la ficha correspondiente, y luego
introduciendo lo siguiente en los formularios:

\begin{itemize}
\item {Texto al abrir 1:
	\begin{itemize}
	\item {Condición: self.isClosed()}
	\item {Éxito: sí}
	\item {Texto: Abres la caja.}
	\end{itemize}}
\item {Texto al abrir 2:
	\begin{itemize}
	\item {Condición: self.isOpen()}
	\item {Éxito: no}
	\item {Texto: ¡No puedes abrir la caja porque ya está abierta!}
	\end{itemize}}
\item {Texto al cerrar 1:
	\begin{itemize}
	\item {Condición: self.isClosed()}
	\item {Éxito: no}
	\item {Texto: ¡No puedes cerrar la caja porque ya está cerrada!}
	\end{itemize}}
\item {Texto al cerrar 2:
	\begin{itemize}
	\item {Condición: self.isOpen()}
	\item {Éxito: sí}
	\item {Texto: Cierras la caja.}
	\end{itemize}}
\end{itemize}

De esta forma, conseguimos una caja que funciona de la manera más normal:
se puede abrir si está cerrada, se puede cerrar si está abierta, y las
otras posibles combinaciones (como abrirla si ya está abierta) no funcionan
y nos dan un mensaje que podemos personalizar. Sin embargo, el sistema de
condiciones también nos da la posibilidad de crear cosas abribles y
cerrables que funcionen de maneras más extrañas, si es necesario.

Para definir el estado inicial de un objeto abrible/cerrable, podemos
utilizar la propiedad closed: si vamos a la ficha ``Propiedades'' del panel
de nuestra caja y añadimos una propiedad closed con valor \textsf{true} y
tiempo restante $-1$ (infinito), la caja comenzará estando cerrada. De lo
contrario, empezará abierta hasta que alguien la cierre.

\subsection {Llaves}

Si además queremos que para abrir una cosa abrible o cerrable haga falta
tener en posesión otro objeto (que comúnmente llamamos llave), podemos
hacerlo marcando la cosa como abrible/cerrable con llave y utilizando los
otros dos formularios, que procesan las órdenes de tipo \textsf{cerrar X con
Y} y \textsf{abrir X con Y}. Éstos funcionan exactamente igual que los
formularios para \textsf{abrir X} y \textsf{cerrar X} que hemos visto antes,
con la salvedad de que AGE nos proporciona una manera de definir qué objeto
u objetos $Y$ son los que sirven para abrir $X$.

Para hacer esto, creamos una relación (flecha) que vaya de $X$ (el objeto
que se abre) a $Y$ (su llave asociada), y en el panel de la relación, donde
se nos pregunta ``Relación estructural'', marcamos ``Se abre con'' para
expresar que $X$ se abre con $Y$. Es posible definir de esta manera varias
llaves que abran una misma puerta, o varias puertas que se abran con una
misma llave, creando varias flechas.

De este modo, cuando un jugador teclea una orden \textsf{abrir X con Y}, si
$X$ e $Y$ son cosas válidas y que están al alcance del jugador, AGE hace lo
siguiente:

\begin{enumerate}
\item {Si la cosa $X$ no está marcada como ``Abrible con llave'', se le dice
al jugador que no tiene sentido abrir eso con llave.}
\item {Si la cosa $X$ está marcada como ``Abrible con llave'', se recorren
las descripciones del formulario ``Texto al abrir con llave'', procediendo
de forma análoga a como se hacía para el formulario ``Texto al abrir'';
pero con una diferencia, que es la siguiente: si el objeto $Y$ no es una
llave válida para abrir $X$, sólo se considerarán las descripciones ``Sin
éxito''; mientras que si el objeto $Y$ sí es una de las llaves válidas para
abrir $X$, se considerarán tanto las descripciones ``Sin éxito'' como
aquellas ``Con éxito''.}
\end{enumerate}

De esta manera, AGE nos comprueba automáticamente que el jugador lleva la
llave adecuada, y hace que la acción de abrir con llave no tenga éxito en
caso contrario; pero seguimos pudiendo utilizar las condiciones de las
descripciones para determinar si hay éxito o fracaso en el caso de que el
jugador sí tenga la llave (por ejemplo, tal vez el jugador tiene la llave
pero la puerta está atrancada...)

La acción de abrir con llave se comporta de forma totalmente análoga a la
acción cerrar con llave, pero usando los formularios correspondientes.

La propiedad 'locked' nos permite definir inicialmente si una cosa va a
estar cerrada con llave o no: poniendo dicha propiedad a 'true' y con
temporizador $-1$ en la ficha de ``Propiedades'' de una cosa, nos
aseguraremos de que empiece cerrada con llave al principio del juego.

Nótese que con el sistema de apertura y cierre con llave aquí descrito se
implementa por defecto el manejo de llaves típico de los juegos americanos
clásicos, en los que para abrir una puerta primero hay que ``abrirla con
llave'' (unlock), que corresponde sólo a girar la llave, y después
``abrirla'' realmente (open). En el mundo hispanohablante, muchos autores
actuales prefieren un sistema más simple en el que al poner ``abrir puerta''
ya se abra con llave automáticamente (incluyendo las acciones unlock+open)
en el caso de que el jugador tenga la llave. Este sistema de apertura y
cierre fácil de conseguir en AGE, simplemente ignorando las casillas y
formularios de ``Abrible con llave'' y ``Cerrable con llave'' y definiendo
las condiciones del ``abrir'' y ``cerrar'' normales para que miren si el
jugador tiene la llave. Otras variantes se pueden definir de forma similar.

\subsection {Puertas}

Un uso común de las cosas abribles o cerrables es que sirvan como puertas
de acceso entre una localidad y otra, de forma que haya sea necesario abrir
la puerta para atravesar el camino correspondiente.

Para definir una puerta entre dos habitaciones, hacemos lo siguiente:

\begin{itemize}
\item {Creamos una cosa abrible/cerrable que represente la puerta. Podemos
hacerlo de forma similar a la caja vista en el ejemplo anterior, o podemos
hacer cambios (como añadir la funcionalidad de abrir/cerrar con llave)
según cómo queramos que funcione la puerta.}
\item {Hacemos click en el camino o caminos entre las dos localidades y, en
la ficha ``Relación estructural'' de su panel de relación, vamos a donde
pone ``Puerta:'' y seleccionamos nuestra entidad puerta. Lo que hace esto
es vincular el camino con la puerta de forma que si el jugador intenta andar
por ese camino y la puerta está cerrada, fracasará en su empeño.}
\item {Añadimos la puerta a las dos localidades (mediante flechas de cada
una de las localidades a la puerta). Si no hacemos esto, el camino estaría
vinculado a la puerta pero ésta no sería accesible desde las localidades,
de manera que no podríamos abrirla o cerrarla, por ejemplo.}
\end{itemize}

Aunque no es necesario para que la puerta funcione, muchas veces será
conveniente no ponerle nombres para mostrar. Esto hace que no se muestre
tras la descripción de las habitaciones (o sea, que no aparezcan cosas como
``Aquí hay una espada, un escudo y una puerta roja'', cosa que suele ser
antinatural). Por supuesto, sí que es necesario que la puerta tenga algún
nombre de referencia para poder manipularla.

\subsection {Contenedores abribles y cerrables}
Otro uso común para las cosas abribles o cerrables es servir para modelar
objetos que hay que abrir para sacar otros objetos de su interior, como
baúles o cajones. Para hacer esto, basta con crear un objeto abrible y/o
cerrable (como la caja vista anteriormente) y definirlo a la vez como
contenedor, y AGE se encargará automáticamente de que sólo se pueda acceder
a los objetos que contiene cuando esté abierta. En la siguiente sección,
contenedores, veremos cómo se define una cosa como contenedor.

\section{Miembros y prendas} \label{sec:MiembrosPrendas}

Una \textit{prenda} es una cosa que los jugadores y criaturas pueden vestir
en alguna parte de su cuerpo. Las prendas pueden tener propósito de
armadura (en los juegos que incluyan combates) o no tenerlo (en el resto de
los juegos). Así, ejemplos de objetos que se pueden modelar como prendas en
AGE podrían ser una cota de mallas, un traje, unos guantes, un guantelete,
unas botas o incluso un anillo o un pendiente.

Las prendas se ponen y se quitan por defecto mediante las órdenes
\textsf{vestir prenda} y \textsf{desvestir prenda}. A partir de la versión
1.0.3 de AGE, las órdenes \textsf{poner jugador prenda} (ponerse prenda) y
\textsf{coger jugador prenda} (quitarse/sacarse prenda) también funcionan
para ponerse y quitarse prendas.

Una prenda en AGE siempre se pone en una o varias partes del cuerpo, esto
permite crear un sistema de prendas realista (por ejemplo, si tenemos un
yelmo puesto no nos podremos poner otro a la vez, porque ambos ocuparían la
cabeza; pero sí que podemos tener puestos a la vez un yelmo y unas botas
porque el primero va en la cabeza y las segundas en los pies).

Así pues, el sistema de prendas en AGE va ligado al sistema de partes del
cuerpo (miembros), que es el que sirve para decidir qué prendas pueden
combinarse con otras. No obstante, si en un mundo de AGE no es necesario
este nivel de complejidad, se puede simplificar, como se verá más adelante.

\subsection {Miembros}

Los miembros son cosas que representan las partes del cuerpo de un jugador
o criatura. Con la funcionalidad por defecto del AGE, la utilidad de los
miembros es que sirven para blandir armas así como para vestir prendas y
armaduras. Por supuesto, el creador de aventuras puede dar otros usos a los
miembros programando en BeanShell si lo considera necesario.

Para definir un miembro, como por ejemplo la cabeza del jugador, la añadimos
en el PUCK como una cosa cualquiera, rellenando los campos (nombre único,
nombre de referencia, género, etc.) que sean necesarios. A continuación,
creamos una relación estructural que vaya del jugador a la cabeza. Por
defecto, la flecha resultante está etiquetada con la palabra ``tiene'', que
quiere decir que la cabeza está en el inventario del jugador (como si éste
llevase una cabeza cortada consigo). Para ponerla como miembro, hacemos
click en la flecha de la relación, y en la ficha ``Relación estructural''
del panel asociado cambiamos ``tiene'' por ``se compone de''. De este modo,
la cabeza pasa a ser un miembro del jugador, tal y como queremos.

Es posible hacer que un miembro se componga de otros miembros (por ejemplo,
que una mano tenga varios dedos) creando relaciones ``se compone de'' entre
unos y otros. Sin embargo, esto no es necesario, al menos con la
funcionalidad por defecto del AGE. Si queremos tener anillos que se pongan
en los dedos, en la práctica es igualmente válido poner éstos como partes
del jugador en lugar de como partes de la mano; aunque un perfeccionista
del modelado pueda querer hacer lo segundo.

Cada criatura puede llevar a cabo acciones sobre sus propios miembros (por
ejemplo, vendarse el brazo izquierdo, suponiendo que definamos la respuesta
al verbo ``vendar'' adecuadamente en el brazo); pero por defecto no puede
llevar a cabo acciones sobre los miembros de los demás.

Si queremos trabajar con los miembros de alguna criatura desde código
BeanShell, podemos utilizar los siguientes métodos:

\begin{lstlisting}
/*clase Mobile*/ Inventory getPartsInventory()
\end{lstlisting}

Este método devuelve una lista de la clase \textsf{Inventory} que contiene
los miembros directos de la criatura sobre la que se invoca. Con directos
queremos decir que, si un brazo está modelado como parte de la criatura y a
su vez una mano como parte del brazo, la lista contendrá el brazo pero no
la mano.

Este inventario se puede modificar, añadiendo o quitando elementos para
añadir o quitar miembros dinámicamente a una criatura.

\begin{lstlisting}
/*clase Item*/ Inventory getParts()
\end{lstlisting}

Devuelve una lista de clase \textsf{Inventory} con las partes de la cosa
dada. En el ejemplo anterior, si lo invocáramos sobre el brazo, devolvería
un inventario conteniendo la mano.

Este inventario se puede modificar, añadiendo o quitando cosas para añadir
o quitar partes dinámicamente a un miembro.

\begin{lstlisting}
/*clase Mobile*/ Inventory getFlattenedPartsInventory()
\end{lstlisting}

Devuelve una lista de clase \textsf{Inventory} conteniendo los miembros
directos e indirectos de la criatura sobre la que se invoca. Es decir, en
el ejemplo anterior, este método devolvería una lista conteniendo tanto el
brazo como la mano.

Al contrario que los anteriores, este inventario es de ``sólo lectura''. Si
se modifica, no tendrá el efecto de añadir ni quitar miembros a la criatura.

\subsection {Prendas} \label{sec:Prendas}

Como se explicó anteriormente, una prenda es una cosa que los jugadores
pueden vestir en alguna parte de su cuerpo. Para crear una prenda en PUCK,
lo hacemos de la siguiente manera:

\begin{itemize}
\item {Creamos una cosa en PUCK, rellenando todos los campos estándar de
nombres, género, descripción, etc.}
\item {Vamos a la ficha ``Prenda'' del panel de entidad de la cosa, y
marcamos la casilla ``Es prenda'', indicando que efectivamente se trata de
una prenda.}
\item {A continuación, tenemos que especificar en qué miembro o miembros de
las criaturas se podrá llevar esa prenda. Por ejemplo, un casco se podrá
llevar en la cabeza. Para hacer esto, utilizamos el formulario llamado
``Miembros requeridos'' de la ficha ``Prenda'':}
\item {Pulsamos el botón ``Añadir miembro''. Esto hace que nos aparezca un
nuevo panel de ``Miembro'', que nos da la opción de añadir una serie de
nombres. Introducimos ``cabeza'', y con esto, el casco ya tiene la
información de que puede ponerse en la cabeza.}
\end{itemize}

Si en lugar de un solo miembro, una prenda necesita ocupar varios (por
ejemplo, unas botas podrían ocupar el pie izquierdo y el pie derecho, si
los modelamos como objetos distintos); entonces le daremos varias veces al
botón ``Añadir miembro'', y en cada uno de los paneles que aparezcan
introduciremos el nombre de uno de los miembros (por ejemplo, ``pie
izquierdo'' en uno, y ``pie derecho'' en el otro).

Por otra parte, si una misma prenda se puede poner en distintos tipos de
miembros (pero sólo en uno de cada vez), lo que haremos será darle a
``Añadir miembro'' una sola vez; pero añadirle varios nombres: por ejemplo,
si un guante es reversible y puede encajar tanto en la mano derecha como en
la izquierda, podríamos poner ``mano derecha'' y ``mano izquierda'' como
nombres en su miembro requerido. Estos nombres siempre se procesan en orden,
es decir, si ponemos primero ``mano derecha'' y después ``mano izquierda''
y el jugador teclea \textsf{vestir guante}, se colocará éste en la mano
derecha si la tiene libre, y sólo en el caso de que no la tenga libre se lo
pondrá en la izquierda.

Si queremos que una criatura comience el juego con una prenda puesta, lo
haremos creando en PUCK una relación llamada ``wears'' con valor
\textsf{true} que vaya del miembro correspondiente a la criatura. Por
ejemplo, si queremos que un jugador comience con un casco puesto en su
cabeza:

\begin{itemize}
\item {Creamos una relación (flecha) de la cabeza al casco,}
\item {Clickeamos en ella,}
\item {Vamos a la ficha ``Otras relaciones'' del panel de la relación,}
\item {Introducimos nombre ``wears'', valor \textsf{true}, y tiempo restante
$-1$ (infinito).}
\end{itemize}

Si queremos modificar desde el código BeanShell las prendas que lleva
puestas o deja de llevar una criatura, basta con poner el valor de la
relación ``wears'' entre cada miembro y la correspondiente prenda a
\textsf{true} o \textsf{false} (véase cómo hacerlo en la sección de
relaciones). También podemos utilizar el mecanismo de relaciones para
consultar qué prendas lleva puesta una criatura y en qué miembros; pero
adicionalmente, AGE nos proporciona métodos para hacer esto más
rápidamente:

\begin{lstlisting}
/*clase Mobile*/ Inventory getWornItems()
\end{lstlisting}

Este método devuelve una lista de todas las prendas que lleva puesta la
criatura sobre la que se invoca. El inventario devuelto es de sólo lectura,
es decir, quitarle y ponerle cosas no tendrá ningún efecto sobre lo que
lleva puesta la criatura (para esto, debemos usar las relaciones).

\begin{lstlisting}
/*clase Mobile*/ Item getWornItem( Item limb )
\end{lstlisting}

Devuelve la prenda que lleva puesta la criatura sobre la que se invoca en
el miembro dado por limb o, si no lleva ninguna prenda, devuelve \textsf{null}.

\begin{lstlisting}
/*clase Mobile*/ boolean wearsItem( Item wearable )
\end{lstlisting}

Sirve para comprobar si la criatura sobre la que se invoca lleva o no
puesta la prenda dada como parámetro. Devuelve \textsf{true} si la lleva
puesta (en cualquiera de sus miembros) y \textsf{false} de lo contrario.

\section {Estados de las criaturas} \label{sec:EstadosCriaturas}

En la sección \ref{sec:Temporizacion} sobre temporización vimos cómo
funcionaba el modelo de tiempo de AGE, basado en unidades de tiempo y en
propiedades cuyo método update se activa cuando su contador de tiempo llega
a cero. En esa sección, vimos algunos ejemplos de cómo usar ese mecanismo
para definir entidades con comportamientos que dependieran del tiempo. Pero,
además de los que nosotros añadamos, en AGE ya existen comportamientos
definidos por defecto que dependen del tiempo, que son los asociados a las
acciones de las criatura, como coger un objeto o moverse en una dirección.
Todas las acciones que llevan a cabo las criaturas consumen un tiempo, y la
cuenta de este tiempo se lleva en el temporizador de una propiedad llamada
``state''.

Por ejemplo, como jugadores, cuando AGE nos acepta una orden de entrada, es
porque ha llegado a cero el temporizador de ``state'' de nuestro personaje
jugador. Si tecleamos ``ir norte'', AGE cambiará el valor de ``state'' a un
valor de estado (que se verá más adelante) que indica que nos estamos
moviendo, y fijará el temporizador al número de unidades de tiempo que nos
consuma ir hacia el norte. Una vez llegado el temporizador a cero, esto
significa que ya hemos terminado de ir hacia el norte y AGE esperará otra
orden de entrada, que de nuevo cambiará el valor y temporizador de ``state'',
y así sucesivamente.

Por lo tanto, el método \textsf{update} que define AGE por defecto para la
propiedad ``state'' de los jugadores es muy importante, porque es nada menos
que el que consigue que al ejecutar una aventura monojugador, ésta nos vaya
pidiendo órdenes y ejecutándolas una por una. En una aventura multijugador
o que cuente con personajes complejos que realicen acciones, el temporizador
de esta propiedad será el que se encargue de entrelazar correctamente las
acciones: por ejemplo, si ir al norte desde una localidad a otra consume
tres unidades de tiempo y coger un objeto consume una unidad de tiempo, el
jugador A podrá coger tres objetos en el tiempo en el que el jugador B va al
norte (la manera concreta en la que los jugadores perciben esto en los modos
síncrono y de tiempo real se trató en la sección de temporización).

En la presente sección veremos en detalle cómo funciona esta propiedad
especial ``state'' (y otra asociada, llamada ``target'') y qué podemos hacer
con ellas.

\subsection{Las propiedades ``state'' y ``target''} \label{sec:StateTarget}

Las criaturas (objetos de la clase \textsf{Mobile}) tienen una propiedad
especialmente importante llamada ``state'' (estado). La importancia de la
propiedad ``state'' radica en que esta propiedad es la que define qué cosa
está haciendo una criatura en cada momento, y su temporizador es el que
indica cuánto tiempo tardará en hacerlo.

Asociada a la propiedad ``state'' aparece a veces otra propiedad, llamada
``target'', que nos proporciona información extendida sobre el estado. Así,
por ejemplo, si en un instante dado del juego la criatura Pepito está yendo
de la sala sur a la sala norte, su propiedad ``state'' en ese momento valdrá
\textsf{Mobile.MOVING} (valor que indica que se está moviendo) y su
propiedad ``target'' contendrá un identificador de la sala norte.\footnote{Por
motivos puramente históricos, el identificador contenido en ``target'' es
un número entero en lugar del nombre único de la sala. Sin embargo, se puede
utilizar igual que si fuera el nombre único (es decir, funcionarán cosas
como \textsf{room(fulano.get("target"))}. Probablemente la propiedad
``target'' pase a contener nombres únicos, en lugar de dichos identifiadores
enteros, en futuras versiones de AGE.}

El manejo de las propiedades ``state'' y ``target'' ha de considerarse un
tema avanzado, pues en la mayoría de los juegos no hace falta manipularlas.
Sólo debería ser necesario en aventuras en las que se quiera tener un
control fino del combate o de la temporización de eventos.

En la siguiente tabla se muestran los valores que puede tomar, para
cualquier criatura, la propiedad ``state'', así como su significado y el uso
de la propiedad ``target'' para ese estado. Nótese que gran parte de los
estados, aunque no todos, están relacionados con el combate y se tratarán
en más detalle en la sección \ref{sec:CombateArmas} Combate y armas de esta
documentación.
\\
{\footnotesize\begin{tabular}{|l|p{6cm}|p{2.5cm}|}
\hline
\textbf{Valor de ``state''} & \textbf{Significado de ``state''} & \textbf{Significado de ``target''} \\
\hline
\hline
\textsf{Mobile.IDLE} & Estado por defecto. Ojo: el nombre (\textsf{IDLE},
												ocioso) está mal puesto, pues no tiene por qué
												significar que la criatura esté ociosa. Se puede
												utilizar para denotar que la criatura está llevando
												a cabo cualquier acción no contemplada en los otros
												estados. Por ejemplo, es el estado que tiene una
												criatura que está cogiendo o dejando un objeto.  &  \\
\hline
\textsf{Mobile.MOVING } & La criatura está moviendose de una habitación a
													otra. El temporizador de ``state'' indica cuántas
													unidades de tiempo quedan hasta que se complete el
													movimiento. En el momento en que se completa es
													cuando la criatura cambia realmente de habitación,
													y se imprimen los mensajes como ``Fulano se va al
													norte'' o ``Fulano llega desde el sur''. & Habitación destino \\
\hline
\textsf{Mobile.ATTACKING} & La criatura está lanzando un ataque contra otra
														criatura. Cuando el temporizador llegue a cero,
														el ataque impactará al enemigo (si no ha
														sucedido antes algo que lo impida, como que la
														criatura reciba un golpe). & Criatura que recibirá el ataque \\
\hline
\textsf{Mobile.BLOCKING} & La criatura está preparando un bloqueo. Cuando el
														temporizador llegue a cero, la criatura pasará
														a estar ``en guardia'' (\textsf{Mobile.READY\_TO\_BLOCK})
														y si le llega un ataque, será bloqueado. & \\
\hline
\textsf{Mobile.READY\_TO\_BLOCK} & La criatura está bloqueándose, con un
														escudo o arma alzada para parar un ataque enemigo. & \\
\hline
\textsf{Mobile.DODGING} & La criatura está echándose a un lado para intentar
														esquivar un ataque. Si el temporizador llega a
														cero antes de que se reciba el ataque, se
														considerará que le ha dado tiempo a esquivar. & \\
\hline
\textsf{Mobile.READY\_TO\_DODGE} & La criatura está echándose a un lado para
														intentar esquivar un ataque, y ha pasado el
														tiempo suficiente para considerar que le da
														tiempo a esquivar, sin que el ataque haya
														llegado. & \\
\hline
\textsf{Mobile.ATTACK\_RECOVER} & La criatura está recuperándose después de
														haber lanzado una estocada o golpe. Hasta que el
														temporizador del ``state'' llegue a cero, no
														podrá emprender otra acción. & \\
\hline
\textsf{Mobile.BLOCK\_RECOVER} & La criatura está recuperándose después de
														haber parado un golpe. Hasta que el temporizador
														del ``state'' llegue a cero, no podrá emprender
														otra acción. & \\
\hline
\textsf{Mobile.DAMAGE\_RECOVER} & La criatura está recuperándose después de
														haber recibido un golpe. Hasta que el
														temporizador del ``state'' llegue a cero, no
														podrá emprender otra acción. & \\
\hline
\end{tabular}}

{\footnotesize\begin{tabular}{|l|p{6cm}|p{2.5cm}|}
\hline
\textbf{Valor de ``state''} & \textbf{Significado de ``state''} & \textbf{Significado de ``target''} \\
\hline
\hline
\textsf{Mobile.DODGE\_RECOVER} & La criatura está recuperándose después de
														haber llevado a cabo una esquivada con éxito.
														Hasta que el temporizador del ``state'' llegue a
														cero, no podrá emprender otra acción. & \\
\hline
\textsf{Mobile.DYING} & La criatura está cayendo muerta. Este estado siempre
														dura una unidad de tiempo nada más, y luego se
														pasa al estado \textsf{Mobile.DEAD}. & \\
\hline
\textsf{Mobile.DEAD} & La criatura está muerta. & \\
\hline
\textsf{Mobile.SURPRISE\_RECOVER} & La criatura está recuperándose de una
														sorpresa o interrupción. & \\
\hline
\textsf{Mobile.DISABLED} & La criatura está desactivada y no reaccionará
														ante nada, ni recibirá entradas si es un jugador.
														Este estado se usa, por ejemplo, cuando el
														jugador que controlaba un personaje en una
														aventura multijugador se ha caído o desconectado. & \\
\hline
\textsf{Mobile.CASTING} & La criatura está lanzando un conjuro. & Entidad a la que se le lanza el hechizo, si la hay \\
\hline
\end{tabular}}

\subsection{Cambios de estado}

He aquí lo que sucede por defecto en AGE cuando el temporizador del estado
de una criatura llega a cero, a no ser que nosotros como programadores
redefinamos el método update para que haga algo distinto con la propiedad
``state'': 

{\footnotesize\begin{tabular}{|l|p{8cm}|}
\hline
\textbf{Valor de ``state''} & \textbf{Reacción de las criaturas} \\
\hline
\hline
\textsf{Mobile.IDLE} & Tomar decisión \\
\hline
\textsf{Mobile.MOVING} & Tomar decisión \\
\hline
\textsf{Mobile.ATTACKING} & Se lleva a cabo el ataque y se pasa a \textsf{Mobile.ATTACK\_RECOVER} \\
\hline
\textsf{Mobile.BLOCKING} & Se pasa a \textsf{Mobile.READY\_TO\_BLOCK} \\
\hline
\textsf{Mobile.READY\_TO\_BLOCK} & Se refresca el estado hasta que llegue el ataque enemigo, y en ese momento se pasa a \textsf{BLOCK\_RECOVER} o \textsf{DAMAGE\_RECOVER} según el resultado \\
\hline
\textsf{Mobile.DODGING} & Se pasa a \textsf{Mobile.READY\_TO\_DODGE} \\
\hline
\textsf{Mobile.READY\_TO\_DODGE} & Se refresca el estado hasta que llegue el ataque enemigo, y en ese momento se pasa a \textsf{DODGE\_RECOVER} o \textsf{DAMAGE\_RECOVER} según el resultado \\
\hline
\textsf{Mobile.ATTACK\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.BLOCK\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DAMAGE\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DODGE\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DYING} & Se pasa a \textsf{Mobile.DEAD} \\
\hline
\textsf{Mobile.DEAD} & Se mantiene el estado \\
\hline
\textsf{Mobile.SURPRISE\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DISABLED} & Se mantiene el estado \\
\hline
\textsf{Mobile.CASTING} & Se pasa a \textsf{IDLE} \\
\hline
\end{tabular}}

Los casos en los que esta tabla dice ``Tomar decisión'' quiere decir que la
criatura tiene la iniciativa y puede en ese momento emprender una nueva
acción. Esto tiene un significado distinto según si la criatura es un
jugador o no:

\begin{itemize}
\item {Si se trata de un jugador, cuando llegue el momento de ``Tomar
decisión'' se esperará una orden por parte del cliente del jugador, y se
procesará dicha orden, ejecutando los comportamientos correspondientes.}
\item {Si se trata de una criatura que no es jugador, cuando llegue el
momento de ``Tomar decisión'' se hará lo siguiente:
	\begin{itemize}
	\item {Si tiene enemigos presentes, se llama a la IA de combate que decide
	qué acción de combate tomará la criatura (atacar, bloquear, etc.)}
	\item {Si no tiene enemigos presentes, la criatura simplemente no hará
	nada, quedando indefinidamente en estado \textsf{Mobile.IDLE}.}
	\end{itemize}}
\end{itemize}

Por supuesto, podemos sobreescribir el método update de los personajes no
jugadores definiendo comportamientos más complejos, y así obtener criaturas
que se muevan, sigan rutas, cojan objetos, desempeñen tareas, etc.

\subsection {Programación con estados}

Como programadores de aventuras, el uso más evidente de la propiedad ``state''
es el de comprobar lo que está haciendo una criatura. Por ejemplo, si
queremos saber si un personaje llamado Manolo que está en nuestra habitación
ha empezado a irse hacia otra, podríamos hacer algo como:

\begin{lstlisting}
if ( equals ( get(mobile("Manolo"),"state") , Mobile.MOVING ) )
{
  self.say("¡No te vayas aún, Manolo, que todavía me quedan cosas que contarte!\n");
}
\end{lstlisting}

Además, con \textsf{room(get(mobile("Manolo"),"target"))} podemos obtener la
habitación a la que se está moviendo Manolo, y con
\textsf{getTime(mobile("Manolo"),"state")} tendremos el número de unidades
de tiempo que le faltan para llegar a ella (véase la sección
\ref{sec:Temporizacion} sobre temporización).

Aparte de utilizar la propiedad ``state'' para comprobar el estado de una
criatura, los programadores más osados pueden querer redefinir lo que sucede
en el método update para la propiedad ``state'' y de ese modo cambiar la
manera en la que se comporta una criatura en los cambios de estado. Estos
cambios pueden potencialmente ir desde modificaciones puntuales hasta
cambios radicales que, por ejemplo, modifiquen totalmente la manera en la
que se resuelven los cambios de estado tipo ``Tomar decisión'' cambiando
todo el sistema de parseado de AGE por otro sistema totalmente distinto.
Por supuesto, sólo los programadores avanzados o con mucha práctica en AGE
y con interés en personalizarlo deberían utilizar estas características,
que no son para nada necesarias para hacer un buen juego con AGE.

\section {Combate y armas} \label{sec:CombateArmas}

Aetheria Game Engine fue pensado inicialmente como sistema para crear juegos
de rol de texto mono y multijugador, y por ello cuenta con un completo
sistema para simular combates. Por supuesto, este sistema se puede obviar y
no utilizar, de ahí que AGE también sirva perfectamente para crear juegos de
aventura sin elementos de rol y que, de hecho, la mayoría de los juegos
creados hasta hoy en AGE sean de este último tipo. Sin embargo, para quien
esté interesado en hacer que su mundo permita emocionantes duelos a espada
contra orcos, será interesante leer esta sección.

El sistema de combate de AGE está pensado fundamentalmente para combate
estilo medieval y de fantasía, con armas cuerpo a cuerpo y magia. Sin
embargo, al tratarse de un sistema muy genérico, también es posible
adaptarlo a otras situaciones como pueden ser tiroteos con armas de fuego.

El combate en AGE está fuertemente basado en el sistema de temporización (ver
sección \ref{sec:Temporizacion}), así como en los estados de las criaturas
(ver sección \ref{sec:EstadosCriaturas}). Si no recuerdas bien el contenido
de esas dos secciones, es recomendable echarles un vistazo antes de seguir
con ésta.

\subsection {Elementos de rol básicos}

\subsubsection {Puntos de vida y daño}

Como la inmensa mayoría de los juegos de rol por ordenador (CRPG's), el
sistema de combate de AGE utiliza el modelo de recuento del daño por el cual
una criatura cuenta con un determinado número de \textit{puntos de golpe} o
\textit{puntos de vida} (abreviados como HP, del inglés ``hit points'').
Cuando la criatura recibe daño, por ejemplo por ser golpeada con un arma,
pierde puntos de vida (y a los puntos de vida que se restan de su cifra
total se les llama \textit{puntos de daño}). Los puntos de vida, pues, miden
el nivel de salud que le queda a una criatura, y si en algún momento llegan
a cero o menos, la criatura muere.

Por ejemplo, supongamos que un jugador tiene diez puntos de vida. Si un orco
le ataca con un hacha infligiéndole seis puntos de daño, estos puntos de
daño se restan de sus diez puntos de vida, y por lo tanto el jugador se
queda con sólo cuatro puntos de vida. Si a continuación el orco vuelve a
atacarle y esta vez le inflige siete puntos de daño, el jugador se queda con
$4-7=-3$ puntos de vida. Como esta cantidad de puntos de vida es menor o
igual (en este caso menor) que cero, el jugador muere.

En AGE, podemos definir cuántos puntos de vida tiene una criatura mediante
el panel de criatura de PUCK:

\begin{itemize}
\item {Si hacemos click en una criatura en el mapa de PUCK, en la pestaña
``General'' hay un campo del formulario etiquetado ``HP''. Este campo nos
permite definir la cantidad de puntos de vida con la que empieza la
criatura.}
\item {El campo etiquetado ``HP máx'', situado al lado de ``HP'', nos
permite definir la cantidad de puntos de vida máximos de la criatura (es
decir, la cantidad de puntos de vida que tiene la criatura cuando está
saludable y no ha recibido ningún daño).}
\end{itemize}

Así pues, si ponemos la misma cifra en el campo ``HP'' que en el campo
``HP máx'', esto significará que la criatura está inicialmente saludable. Si
ponemos una cifra menor en ``HP'' que en ``HP máx'', significará que la
criatura ya comienza con algún daño.

Tanto ``HP'' como ``HP máx'' deben tener inicialmente un valor mayor que
cero. No hay límite superior (al menos mientras no te pases de un par de
miles de millones), así que puedes usar distintas escalas: puedes preferir
un mundo donde las criaturas tengan pocos puntos de vida (que un hombre
fuerte tenga diez, y un golpe impresionante haga cinco puntos de daño) o
donde tengan muchos (que un hombre tenga mil puntos de vida, y un golpe
pueda hacer fácilmente doscientos de daño). Lo importante para el
programador será equilibrar su juego de forma que el combate resulte
realista, es decir, que el daño que hacen las armas guarde una buena
proporción con la vida que tienen las criaturas.

Los puntos de vida también se pueden obtener y modificar dinámicamente
mediante código BeanShell:

\begin{lstlisting}
/*clase Mobile*/ int getHP ( )
\end{lstlisting}

Devuelve la cantidad de puntos de vida que tiene actualmente la criatura
sobre la que se invoca.

\begin{lstlisting}
/*clase Mobile*/ void setHP ( int newHP )
\end{lstlisting}

Cambia la cantidad de puntos de vida que tiene la criatura sobre la que se
invoca a la cantidad newHP.

\begin{lstlisting}
/*clase Mobile*/ int getMaxHP ( )
\end{lstlisting}

Devuelve la cantidad de puntos de vida máximos de la criatura sobre la que
se invoca.

\begin{lstlisting}
/*clase Mobile*/ void setMaxHP ( int newMaxHP )
\end{lstlisting}

Cambia la cantidad de puntos de vida máximos que tiene la criatura sobre la
que se invoca a la cantidad \textsf{newMaxHP}. Esto se puede utilizar, por
ejemplo, para implementar subidas de nivel en juegos de rol basados en
niveles. Este método estará disponible a partir de la versión 1.1.7 de AGE.

\subsubsection {Atributos y habilidades}

Otro elemento típico en muchos juegos de rol son los \textit{atributos} y las
\textit{habilidades}.

Los atributos son valores numéricos que describen características físicas e
intelectuales genéricas de un personaje. Por ejemplo, atributos que se
suelen utilizar a menudo en juegos de rol son ``fuerza'', ``constitución'',
``destreza'', ``inteligencia'' o ``carisma''.

Las habilidades, por otra parte, son valores numéricos que describen la
práctica o el talento que un personaje tiene para realizar alguna actividad
específica. Ejemplos de posibles habilidades serían ``espada'', ``trepar'',
``pescar'', ``violín'' o ``diplomacia''.

AGE proporciona, por un lado, un sistema genérico para gestionar los valores
de los atributos y habilidades, que es muy sencillo y prácticamente no hace
nada más que almacenar los valores y permitirnos cambiarlos. Por otra parte,
AGE también proporciona mecánicas específicas asociadas a habilidades de
combate y magia.

Esto quiere decir que AGE nos proporciona toda la infraestructura necesaria
para utilizar las habilidades y atributos en el combate: por ejemplo, el
hecho de que la probabilidad de acertar en un ataque con un arma y el tiempo
que nos consume el ataque dependan de nuestra habilidad con esa arma, o el
hecho de que el utilizar repetidamente el arma haga que nuestra habilidad
con ella aumente con el tiempo. Veremos más detalles sobre esto en las
siguientes secciones.

Por otra parte, si queremos utilizar las habilidades y atributos para
funcionalidad no relacionada con el combate (como podría ser usar una
habilidad de ``violín'' para determinar si un personaje cautiva a su
audiencia en un concierto o no); AGE sólo nos proporciona la infraestructura
básica para almacenar y obtener los valores de esas habilidades y atributos,
el resto (por ejemplo, el código para decidir si el personaje consigue tocar
una pieza determinada o no según su habilidad con el violín) tendremos que
ponerlo nosotros como programadores de aventuras.

La mencionada infraestructura básica para almacenar y obtener valores de
habilidades y atributos consiste en un formulario de PUCK y una serie de
métodos invocables desde código BeanShell.

El formulario es la ficha de ``Características'' del panel asociado a un
personaje, y nos permite fijar los valores iniciales de habilidades y
atributos para ese personaje. Para ello, escribimos el nombre de la
habilidad o atributo (por ejemplo, ``violín'') en el campo ``Nombre'' y su
valor numérico (por ejemplo, 30) en el campo ``Valor'', y pulsamos el botón
``Añadir''. Si queremos rectificar el nombre y valor de un atributo, podemos
hacerlo seleccionándolo en la lista, modificando los datos en los campos
``Nombre'' y ``Valor'', y pulsando ``Cambiar''.

Adicionalmente, AGE proporciona los siguientes métodos en la clase Mobile
para manipular atributos y habilidades:

\begin{lstlisting}
/*clase Mobile*/ int getStat ( String name )
\end{lstlisting}

Devuelve el valor numérico del atributo de nombre dado, por ejemplo
\textsf{mobile("manolo").getStat("inteligencia")} devolverá la inteligencia
de Manolo. Nótese que, si no hemos asignado ningún valor a un atributo, este
método devolverá por defecto un valor de 12 (el tradicional valor por
defecto de los atributos en juegos basados en Dungeons \& Dragons).

\begin{lstlisting}
/*clase Mobile*/ void setStat ( String name , int value )
\end{lstlisting}

Cambia el valor numérico del atributo de nombre \textsf{name} por el nuevo
valor \textsf{value}.

\begin{lstlisting}
/*clase Mobile*/ long getSkill ( String name )
\end{lstlisting}

Devuelve el valor numérico de la habilidad de nombre dado, por ejemplo
\textsf{mobile("manolo").getStat("violín")} devolverá la habilidad de
Manolo para tocar el violín. En este caso, si no se había fijado el valor de
esa habilidad, el valor devuelto por defecto será 0 (¡nadie sabe tocar el
violín sin aprender!)

\begin{lstlisting}
/*clase Mobile*/ void setSkill ( String name , long value )
\end{lstlisting}

Cambia el valor numérico de la habilidad de nombre \textsf{name} por el
nuevo valor \textsf{value}.

Nótese que, aunque los atributos y habilidades no están implementados como
propiedades, se comportan de manera muy similar a éstas. De hecho, para
implementar una habilidad que afecte a alguna actividad externa al combate,
se podría implementar igualmente con una propiedad. Para las relacionadas
con el combate, sin embargo, es necesario emplear este sistema de
habilidades y atributos si se quiere aprovechar toda la funcionalidad de
combate que se describirá más abajo.

\subsection {Mecánica de combate}

El sistema de combate en AGE funciona, grosso modo, de la siguiente manera:

\begin{itemize}
\item {Por defecto, existen tres acciones de combate en AGE: ataques,
bloqueos y esquivadas. Por supuesto, esto no excluye que durante un combate
se puedan perfectamente llevar a cabo otras acciones, como coger cosas, usar
objetos, lanzar hechizos, hablar con el adversario, o cualquier otra cosa
que esté definida en la aventura.}
\item {En un ataque, un personaje A ataca con un arma a un personaje B que
está en su misma habitación. Nótese que cada ataque es, pues, individual de
un personaje a otro, pero eso no quiere decir que los combates tengan que
ser uno contra uno (podría haber dos personajes A y C atacando a B a la vez,
por ejemplo). El ataque consume una cantidad de unidades de tiempo (durante
las cuales el arma está moviéndose para golpear al personaje B), y cuando
transcurren esas unidades de tiempo, se resuelve.}
\item {En un bloqueo, un personaje B intenta defenderse con un arma (nótese
que los escudos cuentan como armas) de un personaje A que lo está atacando.
Para ello, es necesario que A esté lanzando un ataque que todavía no se haya
resuelto (el arma está moviéndose para golpear a B). El bloqueo también
consume una determinada cantidad de unidades de tiempo (la que tarda B en
poner su arma en posición de bloquear el arma de A). Si B es capaz de hacer
esto antes de que llegue el arma de A, se resolverá el ataque con bloqueo,
dando oportunidad a B de defenderse (según su habilidad para hacerlo). Por
otra parte, si el arma de A llega antes de que B sea capaz de colocarse en
posición de bloqueo, el ataque de A se resolverá como si B no hubiera
bloqueado en absoluto.}
\item {En una esquivada, un personaje B intenta quitarse del medio ante un
ataque de un personaje A. De nuevo, es necesario que A esté lanzando un
ataque que todavía no se haya resuelto; y la esquivada consumirá una
determinada cantidad de unidades de tiempo (la que tarda B en apartarse del
paso). Si B es capaz de esquivar antes de que llegue el ataque de A, se
resolverá el ataque con esquivada, dando oportunidad a B de esquivar (según
su habilidad para ello). Por otra parte, si el arma de A llega antes, el
ataque de A se resolverá como si B no hubiera esquivado en absoluto.}
\item {Así, cuando se resuelve un ataque pueden pasar las siguientes cosas:
	\begin{enumerate}
	\item {Que el golpe de A sea fallido, y por lo tanto no impacte a B.}
	\item {Que el golpe de A sea bueno, pero B llegue a tiempo para esquivar y
	esquive con éxito, por lo tanto el ataque no impactará a B y éste no
	recibirá daño.}
	\item {Que el golpe de A sea bueno, y B llegue a tiempo para esquivar pero
	su esquivada sea fallida (se lanzó hacia el lado equivocado o lo hizo
	mal), con lo cual el ataque le impactará igual y B recibirá daño.}
	\item {Que el golpe de A sea bueno, pero B llegue a tiempo para bloquear y
	bloquee con éxito, con lo cual el ataque le impacta pero el bloqueo
	absorbe todo o parte del daño.}
	\item {Que el golpe de A sea bueno, y B llegue a tiempo para bloquear,
	pero su bloqueo sea fallido (no colocó el arma o escudo bien para detener
	el golpe de A), con lo cual el ataque le impactará como si no hubiera
	bloqueado y recibirá todo el daño.}
	\end{enumerate}}
\item {Todas estas acciones tienen además un ``tiempo de recuperación''
después de que se produzcan: por ejemplo, después de lanzar un ataque, el
personaje que ha atacado estará unos instantes sin poder hacer otra cosa,
porque lógicamente volver a posicionar el brazo y el arma para lanzar otra
estocada o bloqueo consume un tiempo. Asimismo, el bloqueo y la esquivada
tienen un tiempo de recuperación, y también existe otro tiempo de
recuperación (que normalmente será mayor) al recibir un golpe, ya que lo
normal es que alguien que sufre un ataque en combate quede aturdido durante
unos instantes hasta que pueda reaccionar de nuevo.}
\end{itemize}

A la luz de esta descripción, si quieres (aunque no es realmente necesario
para implementar combates, si no quieres hacer cosas avanzadas) puedes
volver a mirar los estados relacionados con el combate presentes en la tabla
de la sección \ref{sec:StateTarget} sobre Las propiedades ``state'' y
``target'' de las criaturas. Como comprobarás, dichos estados se usan para
implementar lo que acabamos de describir:

\begin{itemize}
\item {Cuando el personaje A lanza su ataque con un arma, se pone en estado
\textsf{Mobile.ATTACKING}, y su propiedad ``target'' apunta al personaje B.}
\item {Si el personaje B decide bloquear, se pondrá en estado
\textsf{Mobile.BLOCKING}.}
\item {Si B consigue ponerse en posición de bloqueo antes de que llegue el
ataque de A, se pondrá en estado \textsf{Mobile.READY\_TO\_BLOCK}.}
\item {Si el personaje B decide esquivar, se pondrá en estado
\textsf{Mobile.DODGING}.}
\item {Si a B le da tiempo a eludir el golpe antes de que llegue el ataque
de A, se pondrá en estado \textsf{Mobile.READY\_TO\_DODGE}.}
\item {Cuando se resuelva el ataque de A (es decir, el temporizador de su
propiedad ``state'' llegue a 0), se resolverá de forma diferente si el
estado de B es \textsf{Mobile.READY\_TO\_BLOCK}, \textsf{Mobile.READY\_TO\_DODGE}
u otra cosa. En los dos primeros casos, habrá que hacer ``tiradas de dados''
con las habilidades para ver si el personaje B es capaz de bloquear o
esquivar. En el tercer caso, sólo se resolverá el ataque de A sin ningún
movimiento mitigador por parte de B.}
\item {Los estados \textsf{Mobile.ATTACK\_RECOVER}, \textsf{Mobile.BLOCK\_RECOVER},
\textsf{Mobile.DODGE\_RECOVER} y \textsf{Mobile.DAMAGE\_RECOVER}
corresponden a los tiempos de recuperación descritos anteriormente para
después de atacar, bloquear, esquivar y recibir un golpe, respectivamente.
Hasta que terminen estos estados, los personajes no podrán ejecutar una
nueva acción.}
\end{itemize}

Pero en esta descripción todavía faltan varios cabos sueltos por explicar,
concretamente:

\begin{itemize}
\item {Cómo funciona eso de las armas,}
\item {Cómo se decide cuántas unidades de tiempo exactamente consume cada
acción (ataques, bloqueos, esquivadas) así como cuántas unidades de tiempo
consumen los tiempos de recuperación,}
\item {Cómo se decide cuándo un ataque, un bloqueo y una esquivada tienen
éxito y cuándo no,}
\item {Cómo se decide cuánto daño se hace, y cuánto absorbe un bloqueo.}
\end{itemize}

Una respuesta rápida y resumida a los tres últimos cabos sueltos es que AGE
calcula estos tres resultados usando una combinación de tres tipos de
factores: factores dados por el arma, factores dados por las habilidades y
atributos del jugador que maneja el arma, y por último factores aleatorios
que sirven para dotar de un cierto grado de incertidumbre e
imprevisibilidad al combate. Todos estos factores se explican en la
siguiente sección, que trata de las armas.

\subsection {Armas}

Un \textit{arma} es cualquier cosa (de la clase \textsf{Item}) que un
personaje puede utilizar para lanzar y/o bloquear ataques. Para crear un
arma en PUCK, empezaremos creando una cosa de forma normal, con sus nombres,
descripciones y demás valores que ya conocemos. Para indicar que se trata de
un arma, seleccionaremos la pestaña ``Arma'' de su panel de entidad, y
activaremos la casilla etiquetada ``Es arma'', que indica que la cosa es un
arma. El resto del formulario de la pestaña ``Arma'' nos permitirá
configurar en detalle el arma, como explicaremos en el resto de esta
sección.

\subsubsection {Usar y blandir armas}

Una primera cosa a tener en cuenta es que existen dos tipos de armas según
la manera en que funcionan: armas naturales y armas externas. Las armas
naturales son partes del cuerpo de una criatura que ésta puede usar como
arma (como por ejemplo un puño, que sirve para dar puñetazos). Las armas
externas, las más comunes, son objetos o herramientas que se usan como
armas, como puede ser una espada, un hacha o un escudo.

Para que una cosa funcione como arma natural, necesitaremos definirla como
miembro de una criatura (véase la sección sobre miembros para recordar cómo
se hacía esto). AGE interpreta automáticamente que cualquier cosa que esté
marcada como arma (casilla ``Es arma'') y sea un miembro de una criatura es
un arma natural. Por otra parte, cualquier cosa que esté marcada como arma
pero no sea un miembro de una criatura funcionará como arma externa.

Para utilizar un arma externa, un personaje debe blandirla, cosa que ocupará
uno o varios de sus miembros: por ejemplo, una daga se puede blandir en una
mano, mientras que una espada de dos manos se podrá blandir --como su nombre
indica-- ocupando ambas manos. El sistema para blandir y enfundar armas es
totalmente análogo al sistema visto en la sección \ref{sec:Prendas} de
prendas para vestir y desvestir prendas, es decir:

\begin{itemize}
\item {Las armas se blanden y enfundan con las órdenes \textsf{blandir arma}
y \textsf{enfundar arma}, que funcionan de manera análoga a
\textsf{vestir prenda} y \textsf{desvestir prenda}.}
\item {Al igual que las prendas, las armas ocupan miembros, de forma que no
puede haber varias armas ocupando a la vez el mismo miembro (si blandimos
una espada en la mano derecha, no podemos blandir a la vez un hacha en la
misma mano).}
\item {El formulario ``Miembros requeridos'' de la pestaña Arma de PUCK
funciona exactamente igual que el de la pestaña Prenda, sólo que en este
caso se refiere a miembros requeridos para blandir un arma en lugar de para
vestir una prenda. Por supuesto, esto incluye la posibilidad de que un arma
ocupe varios miembros, y la de que un arma pueda ocupar distintos tipos de
miembros.}
\item {Si queremos que una criatura comience el juego blandiendo un arma,
se hace de forma análoga a cuando hacíamos que comenzara con una prenda
puesta, pero en este caso utilizamos una relación ``wields'' en vez de
``wears''. Es decir, debemos crear una relación ``wields'' que vaya del
miembro en el que se blande el arma al arma en sí, con valor \textsf{true} y
temporizador $-1$ (además de meter el arma en el inventario).}
\item {Podemos comprobar si una criatura está blandiendo algo en un miembro
comprobando el valor de esta relación ``wields'', y hacer que blanda o deje
de blandir un arma modificándolo con los métodos de AGE para manipular
relaciones. Como en el caso de las prendas, AGE también nos proporciona una
serie de métodos que podemos invocar desde BeanShell para saber qué está
blandiendo una criatura de una forma más directa que usando relaciones:}
\end{itemize}

\begin{lstlisting}
/*clase Mobile*/ Inventory getWieldedWeapons()
\end{lstlisting}

Este método devuelve una lista de todas las armas que está blandiendo la
criatura sobre la que se invoca. El inventario devuelto es de sólo lectura,
es decir, quitarle y ponerle cosas no tendrá ningún efecto sobre lo que
lleva puesta la criatura (para esto, debemos usar las relaciones).

\begin{lstlisting}
/*clase Mobile*/ Item getWieldedItem( Item limb )
\end{lstlisting}

Devuelve el arma que lleva blandida la criatura sobre la que se invoca en el
miembro dado por \textsf{limb} o, si no lleva ningún arma ahí, devuelve
\textsf{null}.

\begin{lstlisting}
/*clase Mobile*/ boolean wieldsItem( Item item )
\end{lstlisting}

Sirve para comprobar si la criatura sobre la que se invoca está blandiendo
el arma dada como parámetro. Devuelve \textsf{true} si la lleva blandida (en
cualquiera de sus miembros) y \textsf{false} de lo contrario.

Hasta aquí, hemos visto cómo hacer que los jugadores y criaturas puedan
blandir y enfundar armas. Pero, por supuesto, lo más importante de las armas
es... ¡combatir con ellas!

\subsubsection {Parámetros de combate de las armas}

Los parámetros de combate de las armas se definen en la mitad inferior de la
pestaña ``Arma'', donde hay un formulario dividido a su vez en pestañas
``Ataque'' y ``Bloqueo''. Como su nombre indica, la pestaña ``Ataque'' sirve
para definir cómo se comportará el arma al lanzar ataques, mientras que en
la pestaña ``Bloqueo'' se puede definir su comportamiento al bloquear con
ella.

A continuación se explica brevemente lo que significa cada campo del formulario
de ``Ataque'':

\begin{itemize}
\item {Uso mínimo: número entero que representa el valor mínimo de habilidad
con el arma que debe de tener el personaje para ser capaz de usarla con un
mínimo de éxito. Un arma con un valor de ``uso mínimo'' de cero puede
utilizarla cualquier personaje o criatura que pueda blandirla (otra cosa es
que la utilice bien o falle la mayoría de los ataques). Un arma con un valor
de ``uso mínimo'' mayor que cero no podrá ser usada en absoluto por
personajes cuya habilidad con el arma sea menor que ese valor (véase más
abajo para saber a qué nos referimos exactamente al decir ``habilidad con el
arma'').}
\item {Pendiente de probabilidad: valor numérico (tipo double, es decir,
con decimales) que define la dificultad de la curva de aprendizaje de usar
el arma con éxito, es decir, lo rápido o lento que se aprende a lanzar
ataques certeros. Un valor de $0$ correspondería a una dificultad media o
moderada, valores positivos hacen el aprendizaje más fácil, y negativos más
difícil. Más abajo se explicará con más detalle cómo funcionan estos
valores; pero si no quieres complicarte, puedes poner siempre $0$, o usar
siempre los valores $-1$, $0$ y $1$ para difícil/normal/fácil.}
\item {Tiempo de ataque base: número entero que indica el tiempo (expresado
en unidades de tiempo) que tardará en lanzar un ataque alguien que tiene
justo el nivel de habilidad mínimo para utilizar el arma.}
\item {Pendiente del tiempo de ataque: valor numérico (tipo double) que
define la dificultad de la curva de aprendizaje del arma en cuanto a tiempo,
es decir, lo rápido o lento que se aprende a utilizarla para atacar con más
rapidez a medida que se va usando. De nuevo, $0$ es el valor normal, valores
positivos significan fácil y negativos difícil.}
\item {Tiempo de recuperación en ataque (base y pendiente): como los
anteriores, pero afectando al tiempo que se tarda en recuperarse de un
ataque con el arma (reposicionar el arma después de lanzar una estocada o
golpe).}
\item {Daño de ataque (tipo de daño y fórmula): tipo de daño que inflige el
arma (por ejemplo daño de golpe, cortante, de fuego, etc.) y fórmula que se
utiliza para calcular el daño.

El tipo de daño puede ser cualquier cadena que nosotros usemos en el juego
para identificar una forma de hacer daño, y su propósito es que podamos
hacer que distintas armas o armaduras sean mejores o peores para defenderse
de diferentes tipos de ataque (por ejemplo, un traje ignífugo puede ser muy
bueno para defenderse del daño de fuego hecho con un lanzallamas, pero muy
malo para defenderse del daño físico hecho por una maza). Si no queremos
llegar a este nivel de detalle en el modelado sino que queremos tratar todo
el daño de la misma manera, simplemente podemos poner la misma cadena en el
campo ``tipo de daño'' de todas las armas y armaduras.

La fórmula se utiliza para determinar cuánto daño de cada tipo se hace, y es
una cadena de sumas y restas cuyos términos pueden contener:

	\begin{itemize}
  \item {Un número entero, por ejemplo, 16.}
  \item {Una cantidad multiplicada por un atributo que puede ser FUE, CON,
	INT, SAB, DES, CHA o POD (fuerza, constitución, inteligencia, sabiduría,
	destreza, carisma o poder), por ejemplo, 2FUE.\footnote{Esto es poco
	genérico, porque AGE permite definir los atributos que se quiera pero sólo
	permite incluir estos atributos específicos en las fórmulas de daño. Es
	algo a mejorar en versiones futuras de AGE.}}
  \item {Una tirada de dados, formada por dos números separados por una
	letra D. Por ejemplo, 4D6 significa ``tirar cuatro dados de seis caras y
	sumar su valor''. Esto añade un factor aleatorio al daño.}
	\end{itemize}

Así, por ejemplo, una fórmula de daño válida podría ser: 6+2D4+2FUE,
significando ``seis, más dos dados de cuatro, más dos veces la fuerza del
personaje''.}
\item {Habilidades: conjunto de habilidades que condicionan lo bien que un
personaje utilizará el arma, lo que antes denominábamos ``habilidad con el
arma''. El ``valor'' en este caso es tipo double e indica en qué medida
influye cada una de las habilidades, de forma que la habilidad de un
personaje para usar el arma será la suma del producto de la puntuación que
tiene en cada una de estas habilidades por el campo ``valor''.

Así, a modo de ejemplo, supongamos que tenemos una espada de dos manos, y en
el formulario ``Habilidades'' de la pestaña ``Ataque'' de la pestaña ``Arma''
de esa espada hemos puesto: ``espadas'', con un valor de 2.0, y ``armas de
dos manos'', con un valor de 1.0. Esto tiene las siguientes consecuencias:

	\begin{itemize}
  \item {La habilidad del personaje para manejar esa espada se calcula
	sumando dos veces su habilidad en ``espadas'' y una vez su habilidad en
	``armas de dos manos''. Por ejemplo, si el personaje tiene una habilidad
	en espadas de 100, y una habilidad en armas de dos manos de 50, su
	habilidad para manejar esta espada en particular sería 250 (pero otras
	espadas podrían requerir una combinación distinta de habilidades). Esta
	cantidad de 250 es la que se utiliza para determinar si el personaje llega
	al uso mínimo para poder utilizar esa espada, y además para calcular
	(según los valores de ``base'' y ``pendiente'' comentados) la probabilidad
	de éxito de los ataques con la espada y los tiempos de ataque y
	recuperación.}
  \item {Cada vez que el personaje lance un ataque con la espada, su
	habilidad con ``espadas'' se incrementará en 2, y su habilidad con ``armas
	de dos manos'' se incrementará en 1. Nótese que, por lo tanto, en AGE el
	valor de las habilidades de combate es un contador de uso que crece
	linealmente (si usas la espada el doble de veces, tendrás el doble de
	habilidad). Por supuesto, esto no quiere decir que la probabilidad de
	éxito al usar la espada o el tiempo de ataque evolucionen linealmente, ya
	que eso no sería realista. A continuación veremos con más detalle cómo
	evolucionan, para los interesados en las matemáticas del combate.}
	\end{itemize}}
\end{itemize}

El formulario de bloqueo permite definir los mismos valores que el de
ataque, sólo que referidos a la acción de bloquear con el arma. Así, el
``uso mínimo'' y la ``pendiente de probabilidad'' del bloqueo determinarán
la probabilidad de bloquear con éxito. El ``tiempo de bloqueo'' y ``tiempo
de recuperación del bloqueo'' definen el tiempo que se tarda en preparar un
bloqueo y en volver a tomar la iniciativa tras llevarlo a cabo. El ``daño
bloqueado'' nos permite especificar fórmulas para el daño que absorbemos con
el bloqueo (que se resta al del ataque que nos hayan hecho, quedando en cero
si el daño absorbido es mayor que el daño que ha hecho el ataque). Por
último, el formulario de ``habilidades'' nos permite definir qué habilidades
son relevantes para (y se entrenan al) bloquear con el arma, que podrían o
no ser las mismas que las correspondientes al ataque.

\subsection{Matemática de las armas}

Si bien con lo dicho en la sección anterior es suficiente para definir armas
que se puedan usar en aventuras con combates, sin duda algunos usuarios
estarán interesados en los detalles de las fórmulas matemáticas que AGE
utiliza para calcular tiempos de acciones de combate y probabilidades de
éxito.

Como se ha dicho anteriormente, se supone que el valor de una habilidad es
una estimación lineal del tiempo de experiencia que tiene el personaje
utilizando esa habilidad. Para obtener estimaciones realistas de tiempos y
probabilidades de éxito de ataques a partir de ese valor, necesitaremos
aplicar una función creciente pero de derivada negativa, de acuerdo con el
concepto intuitivo de ``ganancias decrecientes'' que tenemos en la vida
real: inicialmente el aprendizaje de una nueva habilidad suele ser muy
rápido; pero con el tiempo el perfeccionamiento es mucho más lento y
laborioso.

La fórmula que utiliza AGE para esto en el caso de los tiempos de ataque,
bloqueo y otras acciones de combate es la siguiente:

\begin{equation}
tiempo = \frac {tiempobase} {{(\frac {habilidad - uso~minimo} {100} + 1)}^{e^{pendiente}}}
\end{equation}

que, para hacerse una idea, tiene la forma que se ve en la figura
\ref{fig:armas1} (para tiempos base de 25 y 50, y pendientes de -1, 0 y 1).

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth]{imagenes/armas1.png}
\caption[Relación tiempo ataque y Habilidad]{Relación entre el tiempo de
ataque/bloqueo y la habilidad con el arma menos el uso mínimo.} \label{fig:armas1}
\end{figure}

Como vemos, el jugador no tardará en cogerle el truco al arma y reducir
significativamente el tiempo que le lleva usarla, pero más adelante el
aprendizaje irá siendo cada vez más paulatino.

Sin embargo, esa fórmula no lo es todo: para introducir un cierto grado de
variabilidad e incertidumbre en el combate, al tiempo obtenido de la fórmula
se le aplica cada vez una variación aleatoria, sacada de una distribución
gaussiana de media 0 y desviación típica 1/3 t, siendo t el tiempo obtenido
de la fórmula. Con lo cual, el realidad, el comportamiento tendría más bien
este aspecto que muestra la figura \ref{fig:armas4}.

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth]{imagenes/armas4.png}
\caption[Relación tiempo ataque y Habilidad (real)]{Relación entre el tiempo
de ataque/bloqueo y la habilidad con el arma menos el uso mínimo con factores
aleatorios.} \label{fig:armas4}
\end{figure}

Como podemos ver, la incertidumbre que añade la variación gaussiana hace
que, aunque los combatientes experimentados de un arma ataquen más rápido en
general, puede haber casos en los que por una cuestión de suerte un novato
consiga un ataque más rápido que un veterano. Esto añade imprevisibilidad al
combate.

Para la probabilidad de éxito de los ataques y bloqueos se utiliza una
fórmula basada en el mismo principio, que es:

\begin{equation}
probabilidad = 1 - \frac {1} {{(\frac {habilidad - uso~minimo} {100} + 1)}^{e^{pendiente}}}
\end{equation}

Dándonos unas gráficas como las de la figura \ref{fig:armas2} (para
pendientes de $-1$, $-0.5$, $0$, $0.5$ y $1$).

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth]{imagenes/armas2.png}
\caption[Probabilidad de éxito en el combate]{Probabilidad de éxito en el
combate con armas.} \label{fig:armas2}
\end{figure}

Como vemos, la probabilidad tiende rápidamente a $1$ (tener éxito siempre)
en el caso de pendiente $1$, pero no tan rápido con pendientes más
difíciles.

En el caso de la probabilidad, ya que ella misma funciona como factor para
añadir aleatoriedad e incertidumbre, no añadimos ninguna variación
gaussiana.

\subsection {Esquivadas}

Con lo visto en la sección sobre armas, ya sabemos cómo se calculan las
probabilidades de éxito y tiempos de realización de ataques y bloqueos; pero
no hemos visto cómo se calculan estos parámetros para las esquivadas.

Por el momento, la implementación de las esquivadas en AGE aún no está muy
perfeccionada, así que es sencillo: la probabilidad de realizar una
esquivada con éxito es siempre del 20\%, y esquivar consume siempre 15
unidades de tiempo.

En futuras versiones, es posible que esto se complique un poco más.

\subsection {Armaduras}

Las armaduras no son más que prendas que tienen la capacidad especial de
reducir el daño que quien las viste recibe de ataques dirigidos al miembro
donde las lleva.

Para crear una armadura en PUCK, no tenemos más que hacer lo siguiente:

\begin{itemize}
\item {Crear una prenda, tal como hemos visto anteriormente en la sección
sobre prendas.}
\item {En la pestaña ``Prenda'', cubrir el formulario etiquetado como
``Valor de protección''. Este formulario funciona exactamente igual que
aquéllos en los que introducimos las fórmulas de daño de las armas, es
decir: tendremos que poner tipos de daño de los que nos protegerá la
armadura, y fórmulas para calcular cuánto daño absorberá, en el mismo
formato que en el caso de las armas (por ejemplo, 2+2D6).}
\end{itemize}

Una armadura entra en acción cuando un ataque impacta en el miembro donde el
personaje la lleva. Si bien en AGE no existen por defecto comandos
específicos para atacar a un miembro dado (``golpea a Fulano en la cabeza'',
etc.); se supone que cada ataque se dirige a un miembro determinado. Este
miembro se escoge de forma aleatoria, pero de modo que la probabilidad de
elegir cada uno de los miembros de un personaje es proporcional al volumen
del miembro. Se pueden definir miembros de volumen $0$ si se quiere que
nunca reciban ataques (por ejemplo, si queremos poder llevar un anillo en el
dedo, pero que nunca nos lancen un ataque al dedo, cosa que sonaría bastante
rara).

Esto quiere decir que, por ejemplo, si en un personaje definimos los
miembros ``cabeza'' con volumen $10$, ``cuerpo'' con volumen $15$, ``brazo
izquierdo'' con volumen $5$ y ``brazo derecho'' con volumen $5$, entonces de
cada $35$ ataques que reciba el personaje irán como promedio $10$ dirigidos
a la cabeza, $15$ dirigidos al cuerpo, $5$ al brazo izquierdo y $5$ al brazo
derecho. Si ese personaje lleva un casco puesto en la cabeza, ese casco le
protegerá de esa proporción de ataques que van dirigidos a la cabeza.

La reducción de daño otorgada por una armadura se añade a la reducción
otorgada por el bloqueo, si el personaje ha bloqueado.

\subsection{Entrando en combate}

Ahora que sabemos cómo funciona exactamente el combate, vamos a ver cómo
podemos utilizarlo, es decir, cómo hacemos que un personaje de un juego en
AGE luche contra malvados monstruos.

Cuando esté en la misma habitación que otra criatura, un personaje jugador
siempre puede poner el comando \textsf{atacar criatura} para lanzar un
ataque. Por defecto, las criaturas de AGE están hechas de manera que, si
tienen medios para defenderse (algún arma), siempre entrarán en combate si
las atacan, lanzando ataques, bloqueando o esquivando según consideren
oportuno.

Nótese que las órdenes por defecto para bloquear y esquivar son
\textsf{bloquear criatura y esquivar} (no hace falta especificar una
criatura concreta para esquivar, porque se supone que nos apartamos de
cualquier ataque que nos estén lanzando en ese momento).

Si queremos que sea una criatura no jugadora la que empiece la pelea,
podemos hacerlo agregándole enemigos. Toda criatura en AGE tiene una lista
de enemigos con los que entrará en combate si los ve. Podemos manipular esta
lista mediante los siguientes métodos:

\begin{lstlisting}
/*clase Mobile*/ void addEnemy ( Mobile nuevo )
\end{lstlisting}

Añade a \textsf{nuevo} como enemigo del \textsf{Mobile} sobre el que
invocamos este método.

\begin{lstlisting}
/*clase Mobile*/ boolean removeEnemy ( Mobile viejo )
\end{lstlisting}

Quita \textsf{viejo} de la lista de enemigos del \textsf{Mobile} sobre el
que invocamos este método y devuelve \textsf{true}, si estaba en la lista.
En caso de que no estuviese en la lista, este método no hace nada y devuelve
\textsf{false}.

Así, por ejemplo, si tenemos un orco y hacemos

\begin{lstlisting}
mobile("orco").addEnemy(mobile("manolo"));
\end{lstlisting}

el orco atacará automáticamente a Manolo cuando éste aparezca en su
localidad.

Por supuesto, utilizando los métodos asociados a las criaturas y los métodos
update en conjunto con la propiedad ``state'', es posible definir
comportamientos más complejos de los monstruos, como que persigan a su
enemigo o patrullen una zona buscándolo.

\section {Entidades abstractas}

En las secciones preliminares de esta documentación, hemos visto que los
objetos del mundo que aparecen representados en el mapa de PUCK
(habitaciones, cosas, etc.) se denominan \textit{entidades}. Las entidades
son objetos de una clase llamada \textsf{Entity}, que tiene diferentes
subclases (como \textsf{Room}, \textsf{Mobile} o \textsf{Item}) para
representar entidades de distintas características y que juegan diferentes
papeles en el mundo.

Sin embargo, todas estas entidades tienen unas características en común
(que son precisamente lo que hace que sean entidades). Estas
características han ido apareciendo poco a poco a lo largo de esta
documentación; pero nunca las hemos listado explícitamente. Son las
siguientes:

\begin{enumerate}
\item {Toda entidad tiene un nombre único, que no puede coincidir con el de
ninguna otra entidad. Podemos obtener una entidad del mundo a partir de su
nombre único con \textsf{entity("nombre único")} (aunque las entidades de
cada clase también se puedan obtener llamando a una una función específica,
como en \textsf{item("mesa")} o \textsf{mobile("orco")}).}
\item {Toda entidad puede tener definido código BeanShell.}
\item {Toda entidad puede tener propiedades (con un valor y un temporizador)
y relaciones con cualquier otra entidad (también con un valor y un
temporizador). El sistema AGE decrementa los temporizadores de cada
propiedad cada vez que pasa una unidad de tiempo, y cuando uno de estos
temporizadores llega a cero, llama a un método de actualización (\textsf{update}) si
lo hemos definido en BeanShell, que podemos usar para definir lo que sucede
al ``expirar'' la propiedad.}
\end{enumerate}

Hasta ahora, hemos utilizado todas estas características en entidades como
las habitaciones, cosas o criaturas; que además representan objetos
``palpables'' en el mundo con los que se puede interactuar. Pero en
ocasiones, nos puede interesar tener un objeto que también soporte estas
características (código BeanShell, propiedades, relaciones y temporizadores)
pero que no represente ningún objeto concreto o ``palpable'' del mundo. Ésta
es la función que tienen en AGE las entidades abstractas.

Una entidad abstracta es un objeto de la clase \textsf{AbstractEntity}, la
cual, al igual que \textsf{Room} o \textsf{Item}, es una subclase de la
clase \textsf{Entity}. Podemos agregar entidades abstractas al mapa desde
PUCK mediante el botón ``Añadir entidad abstracta'', estas entidades tienen
un icono y se pueden colocar en el mapa como el resto, y también cuentan
con formularios en PUCK al igual que el resto. Sin embargo, el formulario
de una entidad abstracta es más sencillo que el de otros tipos de entidad,
ya que permite introducir poco más que nombre único, código BeanShell y
propiedades.

Así, funcionalmente una entidad abstracta no es más que un contenedor de
código BeanShell, propiedades y relaciones; que nos proporciona toda la
funcionalidad que nos dan estas características de AGE sin necesidad de
traducirse en un objeto concreto y material del mundo que se simula. Sin
embargo, como través del código BeanShell de una entidad abstracta podemos
referirnos a otras entidades y llamar a métodos que las afecten, una
entidad abstracta puede implementar comportamientos que tengan efectos
visibles en el mundo.

Algunos ejemplos de comportamientos que se han implementado con entidades
abstractas son los siguientes:

\begin {enumerate}
\item {Una entidad abstracta ``tiempo atmosférico'' que controle cómo va
cambiando el tiempo en las distintas habitaciones del mundo, propagando los
cambios de unas a otras mediante cambios de una propiedad en esas
habitaciones. Esos cambios de tiempo atmosférico se reflejan en las
correspondientes descripciones dinámicas.}
\item {Una entidad abstracta ``incendio'' que haga que las llamas de un
incendio se vayan propagando por las habitaciones, esto se utilizó en la
aventura ``Fuego''.}
\item {Una entidad abstracta ``guión'' que haga que ciertos eventos de una
historia vayan sucediendo en momentos prefijados en distintas partes del
mundo, esto se utilizó en la aventura ``15 meses y un día''.}
\end{enumerate}

Éstos son sólo ejemplos; pero los comportamientos que se pueden implementar
con entidades abstractas sólo están limitados por el ingenio del
programador.

\section {Conjuros}

\section {Mensajes por defecto}

Muchos de los textos que una aventura de AGE muestra al jugador son textos
que el autor del juego no necesita escribir explícitamente, porque ya están
programados en el AGE. Éstos son lo que llamamos mensajes por defecto. Por
ejemplo, en la siguiente interacción:

\begin{verbatim}
> coger el asdfasdf
¿Qué pretendes coger?
> inventario
No tienes nada.
> coger la piedra
Coges la piedra.
\end{verbatim}

Los tres mensajes que muestra como salida el AGE son mensajes por defecto.
En el caso de los dos primeros, todo el texto que se muestra (``¿Qué
pretendes coger?'' y ``No tienes nada.'') es texto puesto por el sistema
sin necesidad de que el jugador lo especifique en ninguna parte. En el
tercer caso, el texto ``Coges'' proviene asimismo del sistema, mientras que
el sintagma ``la piedra'' se genera dinámicamente porque le hemos dado a
esa entidad el nombre para mostrar ``piedra'' y el género femenino que
implica el artículo ``la''.

\subsection {Cambiar los mensajes por defecto}

En ciertos mundos puede resultar conveniente cambiar los mensajes por
defecto, si es que los que vienen de base con el AGE no nos gustan por
algún motivo. Por ejemplo, en un juego de ambientación medieval podríamos
querer que el sistema se dirigiera al jugador con un tratamiento más
arcaico: ``¿Qué pretende coger vuesa merced?'' o ``Cogéis la piedra.'' Por
supuesto, el AGE proporciona la posibilidad de hacer esto, para lo cual
existen varias maneras.

En primer lugar, observemos el fichero ``lang/messages.lan'' que está dentro
de ``AgeCore.jar'' (este fichero .jar se puede abrir como si fuera un .zip
para ver dicho fichero .lan). En él, podemos ver entradas como:

\begin{verbatim}
#Cuando intentas coger algo que no está en la habitación
get.what=¿Qué pretendes coger?\n
#Mostrar inventario (vacío)
you.have.nothing=No tienes nada.\n
#Cuando coges el objeto $item
you.get.item=Coges $item.\n
\end{verbatim}

Estas entradas describen mensajes por defecto de AGE, en concreto, los
vistos en el ejemplo anterior. La línea que empieza con \verb|#| en cada
entrada es simplemente un comentario que explica de qué trata el mensaje.
El texto anterior al signo ``$=$'' en cada línea sin comentario es el
nombre que identifica ese mensaje por defecto. Lo que hay a la derecha del
signo ``$=$'' es el mensaje en sí, donde los identificadores que tienen el
símbolo del dólar se van a sustituir por nombres de entidades (normalmente
debería ser obvio por el contexto cuáles: por ejemplo, en el último de los
mensajes de ejemplo, el identificador \verb|$item| se sustituye por el
nombre de la cosa que el jugador esté cogiendo, con su artículo
correspondiente).

Si cambiásemos los mensajes de este fichero, estaríamos modificando los
mensajes por defecto de AGE. Pero no es esto lo que queremos hacer, sino
modificarlos para un mundo en particular. Sin embargo, abrir el fichero
``messages.lan'' es útil para esta tarea porque para cambiar mensajes para
un mundo concreto necesitaremos saber el nombre de los mensajes que
queremos redefinir (lo que viene antes del signo $=$, como
\textsf{you.get.item}) así como los parámetros que soportan (en este caso,
\verb|$item|). Sabido esto, existen dos maneras de cambiar los mensajes:

\subsubsection {Cambiar mensaje por mensaje}

Para cambiar un mensaje individual, por ejemplo, si quisiéramos que el
parser nos tratara de ``vos'' al coger una cosa, hacemos lo siguiente:

\begin{lstlisting}
world.getMessages().setMessage( "you.get.item" , "Cogéis $item" );
\end{lstlisting}

El método \textsf{getMessages()} de la clase \textsf{World} nos proporciona
un objeto de la clase \textsf{Messages} que encapsula los mensajes por
defecto, y el método \textsf{setMessage} nos permite cambiar cada uno de
ellos.

Este cambio de mensaje será permanente, es decir, a partir de la llamada a
este método se imprimirá ``Cogéis ...'' cada vez que un jugador coja una
cosa. Sin embargo, en ocasiones también querremos que se imprima un mensaje
por defecto en particular sólo en una ocasión. Para ello, también existe la
posibilidad de cambiar el mensaje sólo para la próxima vez que se imprima.
Así, si por ejemplo quisiéramos que al coger un cubito de hielo se nos
mostrara un mensaje diciendo que está frío, podríamos poner en el código
para la orden ``coger'' sobre el cubito se hiciese algo como:

\begin{lstlisting}
world.getMessages().setNextMessage( "you.get.item" , "Coges $item. ¡Buf, qué frío está!" );
\end{lstlisting}

De esta manera conseguiríamos que se mostrase un mensaje distinto sólo al
coger el cubito; pero no con el resto de las cosas del mundo.

\subsubsection {Cambiar todos los mensajes de una sola vez}

Si queremos personalizar una aventura completa, es posible que queramos
cambiar gran parte de los mensajes por defecto, o incluso todos. En ese
caso, es más sencillo utilizar este método:

\begin{enumerate}
\item {Crear un fichero con el formato del messages.lan (por ejemplo,
haciendo una copia de éste y modificándola).}
\item {Ponerlo en el directorio del mundo.}
\item {Hacer que el mundo ejecute el siguiente código:
\begin{lstlisting}
world.loadMessages(world.getResource("nombrefichero.lan"));
\end{lstlisting}
}
\end{enumerate}

Si no se van a cambiar los mensajes a lo largo de toda la aventura, como
sería lo más común, lo normal sería ejecutar uno de estos códigos en el
método intro (ya que se ejecuta al principio). Si se quieren tener
diferentes mensajes o juegos de mensajes en distintas partes de la historia,
estos métodos se pueden ejecutar en cualquier punto de la misma para
cambiarlos a partir de ese momento (se pueden tener varios ficheros de
mensajes, o se pueden cambiar los mensajes uno por uno varias veces sin
problema).

\subsection {Generar dinámicamente los mensajes por defecto}

Si en una aventura interesa que los mensajes por defecto sean muy dinámicos
y cambiantes (por ejemplo, que cada vez que cojamos un objeto se elija un
mensaje diferente de un conjunto de alternativas de forma aleatoria, o
alguna otra cosa que requiera procesado); es posible controlar mediante
código BeanShell el mostrado del mensaje, pasando por encima tanto de los
mensajes por defecto definidos por AGE como de los establecidos para el
mundo según lo visto en la sección anterior. Para ello, en el objeto mundo,
redefinimos el método

\begin{lstlisting}
String getMessage ( String messageName , Object[] arguments )
\end{lstlisting}

donde como parámetro se nos pasa el nombre del mensaje que AGE quiere
mostrar (por ejemplo, \textsf{you.get.item}) y un array con todas las
entidades u otros objetos relevantes al mensaje (en este caso, el array
tendría longitud 1 y sólo contendría la cosa que se está cogiendo y que se
utilizaría por defecto para sustituir \verb|$item|).

El método debe devolver el mensaje que queremos que se muestre en ese caso,
o bien \textsf{null} si no queremos alterar el comportamiento para ese
mensaje y objetos sino delegar en el mecanismo por defecto de mensajes del
mundo o de AGE.

