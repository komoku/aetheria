// Decompiled by DJ v2.9.9.60 Copyright 2000 Atanas Neshkov  Date: 21/10/02 16:13:33
// Home Page : http://members.fortunecity.com/neshkov/dj.html  - Check often for new version!
// Decompiler options: packimports(3) 

package bsh.util;

import java.awt.*;
import java.awt.event.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.*;
import java.util.Vector;
import javax.swing.*;
import javax.swing.text.*;

// Referenced classes of package bsh.util:
//            GUIConsoleInterface, NameCompletion

public class JConsole extends JScrollPane
    implements GUIConsoleInterface, Runnable, KeyListener, MouseListener, ActionListener, PropertyChangeListener
{
    public static class BlockingPipedInputStream extends PipedInputStream
    {

        public synchronized int read()
            throws IOException
        {
            if(closed)
                throw new IOException("stream closed");
            while(super.in < 0) 
            {
                notifyAll();
                try
                {
                    wait(750L);
                }
                catch(InterruptedException interruptedexception)
                {
                    throw new InterruptedIOException();
                }
            }
            int i = buffer[super.out++] & 0xff;
            if(super.out >= buffer.length)
                super.out = 0;
            if(super.in == super.out)
                super.in = -1;
            return i;
        }

        public void close()
            throws IOException
        {
            closed = true;
            super.close();
        }

        boolean closed;

        public BlockingPipedInputStream(PipedOutputStream pipedoutputstream)
            throws IOException
        {
            super(pipedoutputstream);
        }
    }


    public InputStream getInputStream()
    {
        return in;
    }

    public Reader getIn()
    {
        return new InputStreamReader(in);
    }

    public PrintStream getOut()
    {
        return out;
    }

    public PrintStream getErr()
    {
        return out;
    }

    public JConsole()
    {
        this(null, null);
    }

    public JConsole(InputStream inputstream, OutputStream outputstream)
    {
        cmdStart = 0;
        history = new Vector();
        histLine = 0;
        gotUp = true;
        text = new JTextPane(doc = new DefaultStyledDocument()) {

            public void cut()
            {
                if(text.getCaretPosition() < cmdStart)
                    super.copy();
                else
                    super.cut();
            }

            public void paste()
            {
                forceCaretMoveToEnd();
                super.paste();
            }

        };
        Font font = new Font("Monospaced", 0, 14);
        text.setText("");
        text.setFont(font);
        text.setMargin(new Insets(7, 5, 7, 5));
        text.addKeyListener(this);
        setViewportView(text);
        menu = new JPopupMenu("JConsole\tMenu");
        menu.add(new JMenuItem("Cut")).addActionListener(this);
        menu.add(new JMenuItem("Copy")).addActionListener(this);
        menu.add(new JMenuItem("Paste")).addActionListener(this);
        text.addMouseListener(this);
        UIManager.addPropertyChangeListener(this);
        outPipe = outputstream;
        if(outPipe == null)
        {
            outPipe = new PipedOutputStream();
            try
            {
                in = new PipedInputStream((PipedOutputStream)outPipe);
            }
            catch(IOException ioexception)
            {
                print("Console internal\terror (1)...", Color.red);
            }
        }
        inPipe = inputstream;
        if(inPipe == null)
        {
            PipedOutputStream pipedoutputstream = new PipedOutputStream();
            out = new PrintStream(pipedoutputstream);
            try
            {
                inPipe = new BlockingPipedInputStream(pipedoutputstream);
            }
            catch(IOException ioexception1)
            {
                print("Console internal error: " + ioexception1);
            }
        }
        (new Thread(this)).start();
        requestFocus();
    }

    public void keyPressed(KeyEvent keyevent)
    {
        type(keyevent);
        gotUp = false;
    }

    public void keyTyped(KeyEvent keyevent)
    {
        type(keyevent);
    }

    public void keyReleased(KeyEvent keyevent)
    {
        gotUp = true;
        type(keyevent);
    }

    private synchronized void type(KeyEvent keyevent)
    {
        switch(keyevent.getKeyCode())
        {
        case 10: // '\n'
            if(keyevent.getID() == 401 && gotUp)
            {
                enter();
                resetCommandStart();
                text.setCaretPosition(cmdStart);
            }
            keyevent.consume();
            text.repaint();
            break;

        case 16: // '\020'
        case 17: // '\021'
        case 18: // '\022'
        case 19: // '\023'
        case 20: // '\024'
        case 27: // '\033'
        case 112: // 'p'
        case 113: // 'q'
        case 114: // 'r'
        case 115: // 's'
        case 116: // 't'
        case 117: // 'u'
        case 118: // 'v'
        case 119: // 'w'
        case 120: // 'x'
        case 121: // 'y'
        case 122: // 'z'
        case 123: // '{'
        case 145: 
        case 154: 
        case 155: 
        case 157: 
            break;

        case 38: // '&'
            if(keyevent.getID() == 401)
                historyUp();
            keyevent.consume();
            break;

        case 40: // '('
            if(keyevent.getID() == 401)
                historyDown();
            keyevent.consume();
            break;

        case 8: // '\b'
        case 37: // '%'
        case 127: // '\177'
            if(text.getCaretPosition() <= cmdStart)
                keyevent.consume();
            break;

        case 39: // '\''
            forceCaretMoveToStart();
            break;

        case 36: // '$'
            text.setCaretPosition(cmdStart);
            keyevent.consume();
            break;

        case 85: // 'U'
            if((keyevent.getModifiers() & 2) > 0)
            {
                replaceRange("", cmdStart, text.getText().length());
                histLine = 0;
                keyevent.consume();
            }
            break;

        case 67: // 'C'
            if(text.getSelectedText() != null)
                break;
            if((keyevent.getModifiers() & 2) > 0 && keyevent.getID() == 401)
                append("^C");
            keyevent.consume();
            break;

        case 9: // '\t'
            if(keyevent.getID() == 402)
            {
                String s = text.getText().substring(cmdStart);
                doCommandCompletion(s);
            }
            keyevent.consume();
            break;

        case 11: // '\013'
        case 12: // '\f'
        case 13: // '\r'
        case 14: // '\016'
        case 15: // '\017'
        case 21: // '\025'
        case 22: // '\026'
        case 23: // '\027'
        case 24: // '\030'
        case 25: // '\031'
        case 26: // '\032'
        case 28: // '\034'
        case 29: // '\035'
        case 30: // '\036'
        case 31: // '\037'
        case 32: // ' '
        case 33: // '!'
        case 34: // '"'
        case 35: // '#'
        case 41: // ')'
        case 42: // '*'
        case 43: // '+'
        case 44: // ','
        case 45: // '-'
        case 46: // '.'
        case 47: // '/'
        case 48: // '0'
        case 49: // '1'
        case 50: // '2'
        case 51: // '3'
        case 52: // '4'
        case 53: // '5'
        case 54: // '6'
        case 55: // '7'
        case 56: // '8'
        case 57: // '9'
        case 58: // ':'
        case 59: // ';'
        case 60: // '<'
        case 61: // '='
        case 62: // '>'
        case 63: // '?'
        case 64: // '@'
        case 65: // 'A'
        case 66: // 'B'
        case 68: // 'D'
        case 69: // 'E'
        case 70: // 'F'
        case 71: // 'G'
        case 72: // 'H'
        case 73: // 'I'
        case 74: // 'J'
        case 75: // 'K'
        case 76: // 'L'
        case 77: // 'M'
        case 78: // 'N'
        case 79: // 'O'
        case 80: // 'P'
        case 81: // 'Q'
        case 82: // 'R'
        case 83: // 'S'
        case 84: // 'T'
        case 86: // 'V'
        case 87: // 'W'
        case 88: // 'X'
        case 89: // 'Y'
        case 90: // 'Z'
        case 91: // '['
        case 92: // '\\'
        case 93: // ']'
        case 94: // '^'
        case 95: // '_'
        case 96: // '`'
        case 97: // 'a'
        case 98: // 'b'
        case 99: // 'c'
        case 100: // 'd'
        case 101: // 'e'
        case 102: // 'f'
        case 103: // 'g'
        case 104: // 'h'
        case 105: // 'i'
        case 106: // 'j'
        case 107: // 'k'
        case 108: // 'l'
        case 109: // 'm'
        case 110: // 'n'
        case 111: // 'o'
        case 124: // '|'
        case 125: // '}'
        case 126: // '~'
        case 128: 
        case 129: 
        case 130: 
        case 131: 
        case 132: 
        case 133: 
        case 134: 
        case 135: 
        case 136: 
        case 137: 
        case 138: 
        case 139: 
        case 140: 
        case 141: 
        case 142: 
        case 143: 
        case 144: 
        case 146: 
        case 147: 
        case 148: 
        case 149: 
        case 150: 
        case 151: 
        case 152: 
        case 153: 
        case 156: 
        default:
            if((keyevent.getModifiers() & 0xe) == 0)
                forceCaretMoveToEnd();
            break;
        }
    }

    void doCommandCompletion(String s)
    {
        if(nameCompletion == null)
            return;
        int i;
        for(i = s.length() - 1; i >= 0 && (Character.isJavaIdentifierPart(s.charAt(i)) || s.charAt(i) == '.'); i--);
        s = s.substring(i + 1);
        if(s.length() < 2)
            return;
        String as[] = nameCompletion.completeName(s);
        if(as.length == 0)
        {
            Toolkit.getDefaultToolkit().beep();
            return;
        }
        if(as.length == 1 && !as.equals(s))
        {
            String s1 = as[0].substring(s.length());
            append(s1);
            return;
        }
        String s2 = text.getText();
        String s3 = s2.substring(cmdStart);
        for(i = cmdStart; s2.charAt(i) != '\n' && i > 0; i--);
        String s4 = s2.substring(i + 1, cmdStart);
        StringBuffer stringbuffer = new StringBuffer("\n");
        for(i = 0; i < as.length && i < 10; i++)
            stringbuffer.append(as[i] + "\n");

        if(i == 10)
            stringbuffer.append("...\n");
        print(stringbuffer, Color.gray);
        print(s4);
        append(s3);
    }

    private void resetCommandStart()
    {
        cmdStart = text.getText().length();
    }

    private void append(String s)
    {
        int i = text.getText().length();
        text.select(i, i);
        text.replaceSelection(s);
    }

    String replaceRange(Object obj, int i, int j)
    {
        String s = obj.toString();
        text.select(i, j);
        text.replaceSelection(s);
        return s;
    }

    private void forceCaretMoveToEnd()
    {
        if(text.getCaretPosition() < cmdStart)
            text.setCaretPosition(text.getText().length());
        text.repaint();
    }

    private void forceCaretMoveToStart()
    {
        if(text.getCaretPosition() >= cmdStart);
        text.repaint();
    }

    private void enter()
    {
        String s = getCmd();
        if(s.length() == 0)
        {
            s = ";\n";
        } else
        {
            history.addElement(s);
            s = s + "\n";
        }
        append("\n");
        histLine = 0;
        acceptLine(s);
        text.repaint();
    }

    private String getCmd()
    {
        String s = "";
        try
        {
            s = text.getText(cmdStart, text.getText().length() - cmdStart);
        }
        catch(BadLocationException badlocationexception)
        {
            System.out.println("Internal JConsole Error: " + badlocationexception);
        }
        return s;
    }

    private void historyUp()
    {
        if(history.size() == 0)
            return;
        if(histLine == 0)
            startedLine = getCmd();
        if(histLine < history.size())
        {
            histLine++;
            showHistoryLine();
        }
    }

    private void historyDown()
    {
        if(histLine == 0)
        {
            return;
        } else
        {
            histLine--;
            showHistoryLine();
            return;
        }
    }

    private void showHistoryLine()
    {
        String s;
        if(histLine == 0)
            s = startedLine;
        else
            s = (String)history.elementAt(history.size() - histLine);
        replaceRange(s, cmdStart, text.getText().length());
        text.setCaretPosition(text.getText().length());
        text.repaint();
    }

    private void acceptLine(String s)
    {
        if(outPipe == null)
            print("Console internal\terror: cannot output ...", Color.red);
        else
            try
            {
                outPipe.write(s.getBytes());
                outPipe.flush();
            }
            catch(IOException ioexception)
            {
                outPipe = null;
                throw new RuntimeException("Console pipe broken...");
            }
    }

    public void println(String s)
    {
        print(s + "\n");
        text.repaint();
    }

    public synchronized void print(String s)
    {
        append(s != null ? s : "null");
        resetCommandStart();
        text.setCaretPosition(cmdStart);
    }

    public void println()
    {
        print("\n");
        text.repaint();
    }

    public void error(String s)
    {
        print(s, Color.red);
    }

    public void println(Object obj)
    {
        print((new StringBuffer(String.valueOf(obj))).append("\n"));
        text.repaint();
    }

    public void println(Icon icon)
    {
        print(icon);
        println();
        text.repaint();
    }

    public synchronized void print(Object obj)
    {
        append(String.valueOf(obj));
        resetCommandStart();
        text.setCaretPosition(cmdStart);
    }

    public synchronized void print(Icon icon)
    {
        if(icon == null)
        {
            return;
        } else
        {
            text.insertIcon(icon);
            resetCommandStart();
            text.setCaretPosition(cmdStart);
            return;
        }
    }

    public void print(Object obj, Font font)
    {
        print(obj, font, null);
    }

    public void print(Object obj, Color color)
    {
        print(obj, null, color);
    }

    public void print(String s, Color color)
    {
        print(s, null, color);
    }

    public synchronized void print(Object obj, Font font, Color color)
    {
        AttributeSet attributeset = getStyle();
        setStyle(font, color);
        print(obj);
        setStyle(attributeset, true);
    }

    public synchronized void print(Object obj, String s, int i, Color color)
    {
        AttributeSet attributeset = getStyle();
        setStyle(s, i, color);
        print(obj);
        setStyle(attributeset, true);
    }

    public synchronized void print(Object obj, String s, int i, Color color, boolean flag, boolean flag1, boolean flag2)
    {
        AttributeSet attributeset = getStyle();
        setStyle(s, i, color, flag, flag1, flag2);
        print(obj);
        setStyle(attributeset, true);
    }

    public AttributeSet setStyle(Font font)
    {
        return setStyle(font, ((Color) (null)));
    }

    public AttributeSet setStyle(Color color)
    {
        return setStyle(((Font) (null)), color);
    }

    public AttributeSet setStyle(Font font, Color color)
    {
        if(font != null)
            return setStyle(font.getFamily(), font.getSize(), color, font.isBold(), font.isItalic(), StyleConstants.isUnderline(getStyle()));
        else
            return setStyle(null, -1, color);
    }

    public synchronized AttributeSet setStyle(String s, int i, Color color)
    {
        SimpleAttributeSet simpleattributeset = new SimpleAttributeSet();
        if(color != null)
            StyleConstants.setForeground(simpleattributeset, color);
        if(s != null)
            StyleConstants.setFontFamily(simpleattributeset, s);
        if(i != -1)
            StyleConstants.setFontSize(simpleattributeset, i);
        setStyle(((AttributeSet) (simpleattributeset)));
        return getStyle();
    }

    public synchronized AttributeSet setStyle(String s, int i, Color color, boolean flag, boolean flag1, boolean flag2)
    {
        SimpleAttributeSet simpleattributeset = new SimpleAttributeSet();
        if(color != null)
            StyleConstants.setForeground(simpleattributeset, color);
        if(s != null)
            StyleConstants.setFontFamily(simpleattributeset, s);
        if(i != -1)
            StyleConstants.setFontSize(simpleattributeset, i);
        StyleConstants.setBold(simpleattributeset, flag);
        StyleConstants.setItalic(simpleattributeset, flag1);
        StyleConstants.setUnderline(simpleattributeset, flag2);
        setStyle(((AttributeSet) (simpleattributeset)));
        return getStyle();
    }

    public void setStyle(AttributeSet attributeset)
    {
        setStyle(attributeset, false);
    }

    public void setStyle(AttributeSet attributeset, boolean flag)
    {
        text.setCharacterAttributes(attributeset, flag);
    }

    public AttributeSet getStyle()
    {
        return text.getCharacterAttributes();
    }

    public void setFont(Font font)
    {
        super.setFont(font);
        if(text != null)
            text.setFont(font);
    }

    private void inPipeWatcher()
        throws IOException
    {
        byte abyte0[] = new byte[256];
        int i;
        while((i = inPipe.read(abyte0)) != -1) 
            print(new String(abyte0, 0, i));
        println("Console: Input\tclosed...");
    }

    public void run()
    {
        try
        {
            inPipeWatcher();
        }
        catch(IOException ioexception)
        {
            print("Console: I/O Error: " + ioexception + "\n", Color.red);
        }
    }

    public String toString()
    {
        return "BeanShell console";
    }

    public void mouseClicked(MouseEvent mouseevent)
    {
    }

    public void mousePressed(MouseEvent mouseevent)
    {
        if(mouseevent.isPopupTrigger())
            menu.show((Component)mouseevent.getSource(), mouseevent.getX(), mouseevent.getY());
    }

    public void mouseReleased(MouseEvent mouseevent)
    {
        if(mouseevent.isPopupTrigger())
            menu.show((Component)mouseevent.getSource(), mouseevent.getX(), mouseevent.getY());
        text.repaint();
    }

    public void mouseEntered(MouseEvent mouseevent)
    {
    }

    public void mouseExited(MouseEvent mouseevent)
    {
    }

    public void propertyChange(PropertyChangeEvent propertychangeevent)
    {
        if(propertychangeevent.getPropertyName().equals("lookAndFeel"))
            SwingUtilities.updateComponentTreeUI(menu);
    }

    public void actionPerformed(ActionEvent actionevent)
    {
        String s = actionevent.getActionCommand();
        if(s.equals("Cut"))
            text.cut();
        else
        if(s.equals("Copy"))
            text.copy();
        else
        if(s.equals("Paste"))
            text.paste();
    }

    public void setNameCompletion(NameCompletion namecompletion)
    {
        nameCompletion = namecompletion;
    }

    public void setWaitFeedback(boolean flag)
    {
        if(flag)
            setCursor(Cursor.getPredefinedCursor(3));
        else
            setCursor(Cursor.getPredefinedCursor(0));
    }

    private static final String CUT = "Cut";
    private static final String COPY = "Copy";
    private static final String PASTE = "Paste";
    private OutputStream outPipe;
    private InputStream inPipe;
    private InputStream in;
    private PrintStream out;
    private int cmdStart;
    private Vector history;
    private String startedLine;
    private int histLine;
    private JPopupMenu menu;
    private JTextPane text;
    private DefaultStyledDocument doc;
    NameCompletion nameCompletion;
    final int SHOW_AMBIG_MAX = 10;
    private boolean gotUp;



}