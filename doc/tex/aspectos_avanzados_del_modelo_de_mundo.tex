\chapter {Aspectos avanzados del modelo de mundo}

Con lo que se ha visto en las secciones 1 y 2 de esta documentación, es más
que suficiente para crear aventuras de texto funcionales: hemos visto cómo
construir un mundo con habitaciones y cosas conectadas entre sí, cómo
responder a órdenes del jugador, manipular las entidades (comprobando si un
personaje tiene una cosa, quitando y poniendo elementos en el mundo,
moviendo objetos, etc.) y guardar y manejar datos mediante las propiedades
y relaciones. Hemos visto también cómo se programa en BeanShell, incluyendo
todo lo esencial para crear código que funcione: métodos, estructuras
condicionales, bucles, manejo de arrays y listas, e interpretación de los
mensajes de error del intérprete.

Una vez visto esto, como autor de AGE y de este documento recomiendo que os
pongáis manos a la obra y creéis alguna aventura sencillita para ponerlo a
prueba y cogerle el truco a la herramienta. Y hecho esto, podéis profundizar
más en ésta y las siguientes secciones.

En la presente sección cubriremos algunos aspectos más avanzados del modelo
de mundo que no hemos visto por anterioridad, y que sirven sobre todo para
facilitar la inclusión de objetos y comportamientos que son comunes en las
aventuras y que; aunque se podrían programar \comillas{a mano} con lo que hemos
visto hasta ahora, resulta mucho más cómodo y rápido tener predefinidos:
por ejemplo, el soporte para puertas y objetos abribles y cerrables,
descripciones dinámicas, armas, etc.

Cada parte de esta sección cubre una funcionalidad concreta y cada una de
esas partes se pueden leer independientemente de las demás, de forma que
puedes consultar directamente la funcionalidad que te haga falta.

\section{Descripciones y nombres dinámicos}

Un buen juego no se mantiene siempre estático a lo largo de las partidas;
sino que cambia con el tiempo. AGE proporciona un sencillo mecanismo de
\textit{descripciones y nombres dinámicos} que facilita que las
descripciones y nombres de habitaciones, cosas y personajes puedan cambiar
según las circunstancias. Con esto, se pueden conseguir efectos como:

\begin{itemize}
\item {Que la descripción de una calle cambie según si es de día o de
noche,}
\item {Que cambie según el humor del personaje (lo que para uno es un día
alegre para otro podría ser un día horrible),}
\item {Que la descripción y/o nombre de una cosa cambie según su estado (la
misma espada a lo largo de una aventura puede estar limpia o manchada de
sangre, o tal vez oxidada),}
\item {Que el nombre de un personaje se muestre distinta según si un
jugador lo conoce o no (el jugador podría ver a un personaje como \comillas{un
hombre de mediana edad} cuando no sabe quién es, y una vez que se lo han
presentado verlo como \comillas{Benito}),}
\item {Que el nombre o descripción de una cosa se muestre distinto según
los conocimientos de un jugador (lo que para un bárbaro iletrado es \comillas{un
libro muy grande}, para un mago podría ser \comillas{un tomo sobre magia de
combate}).}
\end{itemize}

Todo esto se consigue de forma sencilla especificando condiciones en las
áreas de nombres y descripciones de PUCK.

\subsection{Descripciones dinámicas}

Las descripciones dinámicas se pueden definir tanto para habitaciones como
para cosas y personajes. Esto se hace introduciendo una lista de
condiciones y descripciones en el cuadro \comillas{Descripciones} de la ficha
\comillas{General} de estas entidades. Para añadir un elemento a esta lista,
introducimos una condición en el campo \comillas{Condición}, la descripción
asociada en el campo \comillas{Descripción}, y pulsamos Añadir. La condición que
introduzcamos en el campo \comillas{Condición} es un pedazo de código BeanShell
con las siguientes características:

\begin{itemize}
\item {Tiene que ser una expresión booleana, es decir, un trozo de código
simple (sin estructuras \textsf{if}, bucles ni puntos y coma; aunque sí
puede tener llamadas a métodos, operaciones, etc.) y que devuelva un valor
de tipo \textsf{boolean} (\textsf{true} o \textsf{false}). Dicho con otras
palabras, la condición puede ser cualquier trozo de código que pudiese ir
como condición de un \textsf{if}.}
\item {Podemos usar la variable \textsf{self} para referirnos al objeto en
que estamos definiendo la descripción, y la variable \textsf{world} para
referirnos al mundo, exactamente igual que en los métodos definidos
mediante BeanShell.}
\item {Adicionalmente, en estos campos de condición tenemos una variable
especial \textsf{viewer} que podemos utilizar para referirnos al jugador o
criatura que está mirando aquello que describimos. Esto se puede usar, por
ejemplo, en los ejemplos de aplicación que proponíamos antes para mostrar
diferentes descripciones a un jugador según su humor o según sus
conocimientos sobre la entidad.}
\end{itemize}

Así, ejemplos de posibles condiciones podrían ser:

\textsf{get(self,"{}oxidada")} -- esta descripción es sólo para si la cosa
que describimos (una espada, por ejemplo) está oxidada.

\textsf{!get(self,"{}oxidada")} -- lo contrario, se muestra sólo si la espada
no está oxidada.

\textsf{get(viewer,"{}conoce",self)} -- descripción que se muestra sólo si el
jugador que está mirando al personaje que describimos ya lo conoce (hecho
descrito por una relación \comillas{conoce}).

\textsf{get(viewer,"humor") > 5} -- mostrar esa descripción sólo si el humor
del jugador que mira es mayor que 5 (si hemos definido el humor como una
propiedad de tipo int que toma valores de 0 a 10, por ejemplo, esto sería
una descripción que sólo se ve si estás de buen humor).

Cuando un jugador mire la entidad cuya descripción dinámica hemos definido
de esta manera, la descripción que se mostrará al jugador será la
concatenación de todas aquellas descripciones de la lista cuyas condiciones
asociadas se cumplan. Nótese que esto quiere decir que podemos construir
descripciones dinámicas \comillas{a trozos}, dividiéndolas en partes con distintas
condiciones. Un ejemplo de esto sería el siguiente, en una habitación:

Condición: en blanco (\comillas{siempre}), descripción: Te encuentras en una
habitación de hotel.

Condición: \textsf{get(self,"luzEncendida")}, descripción: Es una habitación
pequeña y sencilla: sólo tiene una cama, un armario y una pequeña mesilla
de noche.

Condición: \textsf{!get(self,"luzEncendida")}, descripción: La luz está
apagada, y la escasa luz de las farolas que entra desde la ventana apenas
te deja intuir la silueta de una cama.

Condición: \verb|( get(self,"luzEncendida") && get(viewer,"humor") > 5 )|,
descripción: En una de las paredes hay un cuadro de dudoso gusto que
muestra un hombre a caballo.

Condición: \verb|( get(self,"luzEncendida") && get(viewer,"humor") <= 5 )|,
descripción: En una de las paredes hay un cuadro de un hombre a caballo,
tan horriblemente pintado que dan ganas de tirarlo por la ventana.

Así, is por ejemplo la luz estuviera encendida y el humor del jugador fuese
2, se le mostraría esta descripción de la habitación:

\textsf{Te encuentras en una habitación de hotel. Es una habitación pequeña
y sencilla: sólo tiene una cama, un armario y una pequeña mesilla de noche.
En una de las paredes hay un cuadro de un hombre a caballo, tan
horriblemente pintado que dan ganas de tirarlo por la ventana.}

Mientras que si la luz estuviese apagada, se mostraría

\textsf{Te encuentras en una habitación de hotel. La luz está apagada, y la
escasa luz de las farolas que entra desde la ventana apenas te deja intuir
la silueta de una cama.}

\subsection{Nombres dinámicos}

El mismo mecanismo que hemos explicado para las descripciones de
habitaciones, cosas y criaturas se aplica también a los nombres singulares
y plurales para mostrar de las cosas y criaturas. Las características que
deben cumplir las condiciones en este caso son las mismas que para las
descripciones, incluida la posibilidad de utilizar la variable especial
\textsf{viewer}.

Hay, sin embargo, una diferencia: los nombres dinámicos que se muestran a
los jugadores no se construyen \comillas{a trozos} como las descripciones, ya que
eso no tendría mucha utilidad, sino que simplemente se muestra el primer
nombre cuya condición se cumpla. Si hay más de un nombre cuya condición se
cumple, el resto se ignorarán.

\section{Cosas abribles y cerrables}

En muchos juegos basados en texto aparecen objetos que pueden abrirse y
cerrarse. Puertas, ventanas, baúles, cajas fuertes o maletas son ejemplos
típicos de objetos así. El AGE proporciona soporte para crear fácilmente
tales objetos, que los jugadores y criaturas pueden abrir y cerrar con o
sin necesitar para ello una llave, según cómo están configurados.

Grosso modo, el sistema de cosas abribles y cerrables de AGE funciona de la
siguiente manera:

\begin{itemize}
\item {En un momento dado, una cosa puede estar abierta o cerrada.}
\item {Además, una cosa que está cerrada puede estar cerrada con llave o no.}
\item {La orden \textsf{cerrar cosa} introducida por un jugador sirve para
cerrar algo que está abierto, la orden \textsf{abrir cosa} para abrir algo
que está cerrado. Es posible definir condiciones para que estos comandos
funcionen o no según el criterio que se quiera (por ejemplo, una puerta que
no se pueda abrir sin más porque está atrancada, etc.)}
\item {La orden \textsf{abrir cosa con llave} introducida por un jugador
sirve para quitar el cerrojo a algo que está cerrado con llave, y la orden
\textsf{cerrar cosa con llave} hace lo contrario. AGE permite definir qué
cosa del juego es la llave de cada cosa abrible/cerrable con llave. Asimismo,
también se pueden definir condiciones para que estos comandos funcionen o no
(además de la condición implícita de tener la llave).}
\item {En cada cosa, se puede marcar individual e independientemente si es
abrible, cerrable, abrible con llave y cerrable con llave. Esto nos permite
la flexibilidad de definir, por ejemplo, algo que se puede abrir pero no se
puede volver a cerrar una vez abierto; o también de obviar el sistema de
llaves si no las necesitamos en nuestro juego.}
\item {Se pueden crear puertas especificando que una cosa es la puerta
asociada a un camino, de forma que no se dejará pasar al jugador por ella
cuando esté cerrada.}
\item {Si una cosa cerrada es un contenedor, no permitirá a los jugadores
manipular lo que haya en su interior hasta que se abra.}
\end{itemize}

\subsection{Definiendo cosas abribles y cerrables} \label{sec:CosasAbribles}

Para definir una cosa abrible y/o cerrable en nuestro mundo de AGE, creamos
una cosa en el PUCK de forma normal (rellenando su nombre único, nombres de
referencia y demás campos útiles como de costumbre) y a continuación vamos
a la ficha llamada \comillas{Abrir/Cerrar} de su panel de objeto.

Lo primero que vemos en esta ficha son cuatro cuadros que podemos marcar
para determinar si la cosa es \comillas{Abrible}, \comillas{Cerrable}, \comillas{Cerrable con
llave} y \comillas{Abrible con llave}, respectivamente. Así, por ejemplo, si
queremos crear una caja que se pueda abrir y cerrar pero que no necesite
una llave para ello, marcaremos los dos primeros cuadros. Si lo que
queremos es una puerta que además tenga una llave que tenga una cerradura
con llave, los marcaremos todos. Es perfectamente posible marcar cualquier
combinación de acciones posibles: por ejemplo, un plástico donde venga
envuelto un CD de música podría modelarse como un objeto abrible, pero no
cerrable (una vez que lo rompemos, no podemos devolverlo a su estado
original).

A continuación vemos cuatro formularios para textos dinámicos asociadas a
cada una de las cuatro acciones: abrir, cerrar, cerrar con llave y abrir
con llave. Como es lógico, sólo tendremos que cubrir los campos
correspondientes a las acciones que hayamos marcado como posibles en los
cuadros anteriores (por ejemplo, a abrir y cerrar en el caso de la caja).

El formulario de estos textos dinámicos es análogo al de las descripciones
y nombres dinámicos; pero con un añadido: además de especificar una
condición y un texto asociado, también tenemos la posibilidad de marcar o
no una casilla llamada \comillas{Con éxito}. Esta casilla determina si la acción
correspondiente (abrir, cerrar, etc.) se llevará a cabo con éxito o no, en
el caso de que la condición asociada sea cierta. De este modo, en el
formulario de \comillas{Texto al abrir} no sólo estamos definiendo el texto en sí,
sino también las condiciones que son necesarias para que la cosa se pueda
abrir; y lo análogo para \comillas{Texto al cerrar} y el resto de formularios
similares.

Más en detalle, cuando un jugador teclea una orden abrir sobre una cosa,
AGE hace lo siguiente:

\begin{enumerate}
\item {Si la cosa no está marcada como \comillas{Abrible}, se le dice al jugador
que no tiene sentido abrir eso.}
\item {Si la cosa sí está marcada como \comillas{Abrible}, se recorren las entradas
del formulario \comillas{Texto al abrir} comprobando si se cumple la condición de
alguna de ellas. En el caso de que se cumpla la condición de una de ellas:
	\begin{enumerate}
	\item {Si esa entrada del formulario era de \comillas{Éxito} (se marcó la
	casilla \comillas{Con éxito}), entonces se muestra el mensaje correspondiente, y
	la cosa se abre.}
	\item {Si esa entrada del formulario era sin éxito (no se marcó la casilla
	\comillas{Con éxito}), entonces se muestra el mensaje correspondiente; pero no
	se hace ningún cambio en el estado de la cosa.}
	\end{enumerate}
}
\end{enumerate}

El funcionamiento de cerrar es análogo, trabajando en cada caso con la
casilla y el formulario correspondientes a esa orden.

Las condiciones que se pueden teclear en estos formularios son expresiones
booleanas en BeanShell, exactamente igual que para las descripciones y
nombres dinámicos. A menudo, para escribir estas condiciones necesitaremos
tener una forma de saber si una cosa está abierta o cerrada, y si está
cerrada con llave o no. Para ello, podemos usar los siguientes métodos de
la clase \textsf{Item}:

\begin{lstlisting}
/*clase Item*/ boolean isOpen ( )
/*clase Item*/ boolean isClosed ( )
/*clase Item*/ boolean isLocked ( )
/*clase Item*/ boolean isUnlocked ( )
\end{lstlisting}

Estos métodos nos permiten comprobar el estado de las cosas
abribles/cerrables: son métodos booleanos que devuelven \textsf{true} si la
cosa sobre la que los ejecutamos está abierta, cerrada, cerrada con llave o
no cerrada con llave, respectivamente; y false de lo contrario.

De este modo, por ejemplo, podemos definir una caja que se abra y se cierre
marcándola como abrible y cerrable en la ficha correspondiente, y luego
introduciendo lo siguiente en los formularios:

\begin{itemize}
\item {Texto al abrir 1:
	\begin{itemize}
	\item {Condición: self.isClosed()}
	\item {Éxito: sí}
	\item {Texto: Abres la caja.}
	\end{itemize}}
\item {Texto al abrir 2:
	\begin{itemize}
	\item {Condición: self.isOpen()}
	\item {Éxito: no}
	\item {Texto: ¡No puedes abrir la caja porque ya está abierta!}
	\end{itemize}}
\item {Texto al cerrar 1:
	\begin{itemize}
	\item {Condición: self.isClosed()}
	\item {Éxito: no}
	\item {Texto: ¡No puedes cerrar la caja porque ya está cerrada!}
	\end{itemize}}
\item {Texto al cerrar 2:
	\begin{itemize}
	\item {Condición: self.isOpen()}
	\item {Éxito: sí}
	\item {Texto: Cierras la caja.}
	\end{itemize}}
\end{itemize}

De esta forma, conseguimos una caja que funciona de la manera más normal:
se puede abrir si está cerrada, se puede cerrar si está abierta, y las
otras posibles combinaciones (como abrirla si ya está abierta) no funcionan
y nos dan un mensaje que podemos personalizar. Sin embargo, el sistema de
condiciones también nos da la posibilidad de crear cosas abribles y
cerrables que funcionen de maneras más extrañas, si es necesario.

Para definir el estado inicial de un objeto abrible/cerrable, podemos
utilizar la propiedad closed: si vamos a la ficha \comillas{Propiedades} del panel
de nuestra caja y añadimos una propiedad closed con valor \textsf{true} y
tiempo restante $-1$ (infinito), la caja comenzará estando cerrada. De lo
contrario, empezará abierta hasta que alguien la cierre.

\subsection {Llaves}

Si además queremos que para abrir una cosa abrible o cerrable haga falta
tener en posesión otro objeto (que comúnmente llamamos llave), podemos
hacerlo marcando la cosa como abrible/cerrable con llave y utilizando los
otros dos formularios, que procesan las órdenes de tipo \textsf{cerrar X con
Y} y \textsf{abrir X con Y}. Éstos funcionan exactamente igual que los
formularios para \textsf{abrir X} y \textsf{cerrar X} que hemos visto antes,
con la salvedad de que AGE nos proporciona una manera de definir qué objeto
u objetos $Y$ son los que sirven para abrir $X$.

Para hacer esto, creamos una relación (flecha) que vaya de $X$ (el objeto
que se abre) a $Y$ (su llave asociada), y en el panel de la relación, donde
se nos pregunta \comillas{Relación estructural}, marcamos \comillas{Se abre con} para
expresar que $X$ se abre con $Y$. Es posible definir de esta manera varias
llaves que abran una misma puerta, o varias puertas que se abran con una
misma llave, creando varias flechas.

De este modo, cuando un jugador teclea una orden \textsf{abrir X con Y}, si
$X$ e $Y$ son cosas válidas y que están al alcance del jugador, AGE hace lo
siguiente:

\begin{enumerate}
\item {Si la cosa $X$ no está marcada como \comillas{Abrible con llave}, se le dice
al jugador que no tiene sentido abrir eso con llave.}
\item {Si la cosa $X$ está marcada como \comillas{Abrible con llave}, se recorren
las descripciones del formulario \comillas{Texto al abrir con llave}, procediendo
de forma análoga a como se hacía para el formulario \comillas{Texto al abrir};
pero con una diferencia, que es la siguiente: si el objeto $Y$ no es una
llave válida para abrir $X$, sólo se considerarán las descripciones \comillas{Sin
éxito}; mientras que si el objeto $Y$ sí es una de las llaves válidas para
abrir $X$, se considerarán tanto las descripciones \comillas{Sin éxito} como
aquellas \comillas{Con éxito}.}
\end{enumerate}

De esta manera, AGE nos comprueba automáticamente que el jugador lleva la
llave adecuada, y hace que la acción de abrir con llave no tenga éxito en
caso contrario; pero seguimos pudiendo utilizar las condiciones de las
descripciones para determinar si hay éxito o fracaso en el caso de que el
jugador sí tenga la llave (por ejemplo, tal vez el jugador tiene la llave
pero la puerta está atrancada...)

La acción de abrir con llave se comporta de forma totalmente análoga a la
acción cerrar con llave, pero usando los formularios correspondientes.

La propiedad 'locked' nos permite definir inicialmente si una cosa va a
estar cerrada con llave o no: poniendo dicha propiedad a 'true' y con
temporizador $-1$ en la ficha de \comillas{Propiedades} de una cosa, nos
aseguraremos de que empiece cerrada con llave al principio del juego.

Nótese que con el sistema de apertura y cierre con llave aquí descrito se
implementa por defecto el manejo de llaves típico de los juegos americanos
clásicos, en los que para abrir una puerta primero hay que \comillas{abrirla con
llave} (unlock), que corresponde sólo a girar la llave, y después
\comillas{abrirla} realmente (open). En el mundo hispanohablante, muchos autores
actuales prefieren un sistema más simple en el que al poner \comillas{abrir puerta}
ya se abra con llave automáticamente (incluyendo las acciones unlock+open)
en el caso de que el jugador tenga la llave. Este sistema de apertura y
cierre fácil de conseguir en AGE, simplemente ignorando las casillas y
formularios de \comillas{Abrible con llave} y \comillas{Cerrable con llave} y definiendo
las condiciones del \comillas{abrir} y \comillas{cerrar} normales para que miren si el
jugador tiene la llave. Otras variantes se pueden definir de forma similar.

\subsection {Puertas}

Un uso común de las cosas abribles o cerrables es que sirvan como puertas
de acceso entre una localidad y otra, de forma que haya sea necesario abrir
la puerta para atravesar el camino correspondiente.

Para definir una puerta entre dos habitaciones, hacemos lo siguiente:

\begin{itemize}
\item {Creamos una cosa abrible/cerrable que represente la puerta. Podemos
hacerlo de forma similar a la caja vista en el ejemplo anterior, o podemos
hacer cambios (como añadir la funcionalidad de abrir/cerrar con llave)
según cómo queramos que funcione la puerta.}
\item {Hacemos click en el camino o caminos entre las dos localidades y, en
la ficha \comillas{Relación estructural} de su panel de relación, vamos a donde
pone \comillas{Puerta:} y seleccionamos nuestra entidad puerta. Lo que hace esto
es vincular el camino con la puerta de forma que si el jugador intenta andar
por ese camino y la puerta está cerrada, fracasará en su empeño.}
\item {Añadimos la puerta a las dos localidades (mediante flechas de cada
una de las localidades a la puerta). Si no hacemos esto, el camino estaría
vinculado a la puerta pero ésta no sería accesible desde las localidades,
de manera que no podríamos abrirla o cerrarla, por ejemplo.}
\end{itemize}

Aunque no es necesario para que la puerta funcione, muchas veces será
conveniente no ponerle nombres para mostrar. Esto hace que no se muestre
tras la descripción de las habitaciones (o sea, que no aparezcan cosas como
\comillas{Aquí hay una espada, un escudo y una puerta roja}, cosa que suele ser
antinatural). Por supuesto, sí que es necesario que la puerta tenga algún
nombre de referencia para poder manipularla.

\subsection {Contenedores abribles y cerrables}
Otro uso común para las cosas abribles o cerrables es servir para modelar
objetos que hay que abrir para sacar otros objetos de su interior, como
baúles o cajones. Para hacer esto, basta con crear un objeto abrible y/o
cerrable (como la caja vista anteriormente) y definirlo a la vez como
contenedor, y AGE se encargará automáticamente de que sólo se pueda acceder
a los objetos que contiene cuando esté abierta. En la siguiente sección,
contenedores, veremos cómo se define una cosa como contenedor.

\section{Contenedores}

Los \emph{contenedores} son cosas que pueden contener otras cosas, y en donde es
posible poner nuevas cosas o quitar las que ya hay.

Así, los contenedores se pueden utilizar para modelar objetos que pueden tener a
otros en su interior, como un baúl o una maleta; o también para objetos que
pueden tener otros encima, como una mesa.

\subsection{Definición y uso de contenedores}
Definir un contenedor con PUCK no podría ser más sencillo: simplemente creamos
una cosa y, en la ficha \comillas{General} de su panel de entidad, marcamos la
casilla que pone \comillas{Contenedor}. Con eso, la cosa queda marcada como
contenedor y se podrán meter otras cosas en ella.

Para que el contenedor empiece el juego conteniendo alguna cosa, no tenemos más
que usar PUCK para crear una relación estructural de tipo \comillas{contiene}
que vaya del contenedor a la cosa contenida. Éste es el tipo de relación que se
crea por defecto cuando creamos una flecha que va de una cosa a otra, así que no
necesitaremos ir a ningún panel sino que con crear la flecha será suficiente.

Por defecto, los usuarios pueden usar las órdenes \textsf{poner/meter cosa en
contenedor} y \textsf{coger/sacar/quitar cosa de contenedor} para poner y quitar
cosas de los contenedores. En el caso de que un contenedor sea cerrable, esto
sólo se podrá hacer cuando está abierto.

A la hora de capturar estas acciones en métodos de análisis de la entrada, es
útil saber que los verbos \comillas{quitar} y \comillas{sacar} se traducen
automáticamente a \comillas{coger}, con lo cual con capturar el verbo
\comillas{coger} es suficiente. Del mismo modo, el verbo \comillas{meter} se
traduce automáticamente a \comillas{poner}, así que capturar este último es
suficiente.

A la hora de definir la descripción de un contenedor, a menudo interesará que en
ella se muestren los objetos que contiene. Por ejemplo, puede interesar que la
descripción de un baúl abierto sea \comillas{Es un bonito baúl. Está abierto. En
su interior hay una espada y un escudo.} Para conseguir este efecto, lo más
sencillo es utilizar en las descripciones del contenedor la palabra clave
\textsf{\%INVENTORY}, que se sustituirá por la descripción de su inventario. Así, una
descripción como la anterior se conseguiría poniendo como descripción
\comillas{Es un bonito baúl. Está abierto. En su interior hay \textsf{\%INVENTORY}}.
Jugando con las descripciones dinámicas y el método \textsf{isClosed()} visto en
la sección \ref{sec:CosasAbribles} sobre cosas abribles y cerrables, podemos
conseguir que los objetos que hay dentro del baúl sólo se muestren cuando está
abierto. Pero el mecanismo es muy flexible: si en su lugar tuviésemos una caja
transparente, podríamos poner la palabra clave \textsf{\%INVENTORY} tanto en la
descripción que se muestra cuando está abierta como en la correspondiente a
cuando está cerrada, para que se puedan ver los objetos que contiene a través
del cristal.

En aventuras que utilicen contenedores, a menudo nos interesará consultar y
manipular su contenido mediante código BeanShell: igual que en la sección sobre
manipulación básica de entidades veíamos cómo enterarnos de qué cosas había en
una habitación o en el inventario de una criatura, así como ponerlas y
quitarlas; lo mismo se puede hacer con los contenedores. El siguiente método
BeanShell es útil para ello:

\begin{lstlisting}
/*clase Item*/ Inventory getContents ( )
\end{lstlisting}

Invocado sobre un contenedor c, este método nos devuelve un inventario de su
contenido. Este inventario se representa mediante un objeto de la clase
\textsf{Inventory} (véase \ref{sec:Inventario} Inventario (Inventory)), y
podemos utilizar los métodos de dicha clase no sólo para comprobar si una cosa
dada está dentro del contenedor, sino también para añadirle y quitarle cosas.

Nótese que esto contrasta con añadir y quitar cosas de los inventarios de
habitaciones y criaturas, donde vimos que era mejor hacerlo mediante métodos
específicos en lugar de trabajar con la clase \textsf{Inventory}.

Con esto tenemos todo lo necesario para crear juegos que trabajen con
contenedores. Sin embargo, es recomendable tener en cuenta una advertencia: no
es recomendable abusar de este recurso. Aunque los contenedores son interesantes
cuando se integran de forma natural en el argumento de un juego o en los
acertijos que plantea (por ejemplo, si es necesario encontrar la llave de un
baúl para obtener una poderosa arma); usados en exceso para modelar en el mundo
cosas que no los necesitan tiende a hacer que los juegos resulten menos
naturales y más incómodos para los jugadores.

Por ejemplo, si tienes un mundo donde para cortar un chorizo es necesario
\comillas{coger cuchillo de mesa}, \comillas{coger tabla de cajón},
\comillas{poner tabla en mesa}, \comillas{poner chorizo en tabla} y
\comillas{cortar chorizo con cuchillo}; en la mayoría de los casos ese nivel de
detalle no va a aportar nada al argumento o a los acertijos salvo aburrir al
jugador. Sería un mejor diseño no usar contenedores en absoluto y que se pudiese
\comillas{cortar chorizo con cuchillo} directamente, poniendo si se quiere un
texto descriptivo que diga que el jugador ha usado una tabla.

Este sobreuso de contenedores es, en la opinión personal del autor, uno de los
vicios de diseño más comunes que se cometen al crear juegos basados en texto (e
incluso otros tipos de juego); y debería evitarse utilizando los contenedores
sólo cuando sean estrictamente necesarios y aporten algo al argumento del juego
que no sería posible sin ellos. Es decir, hablando en plata, casi nunca.

\subsection{Acciones sobre objetos contenidos}

Por defecto, sobre una cosa que está dentro de un contenedor no se puede hacer
nada sin sacarla antes del contenedor, excepto mirarla: por ejemplo, si hay un
libro dentro de un baúl, el jugador tendrá que primero coger libro o sacar libro
de baúl para a continuación poder leerlo, no podrá hacerlo directamente.

Esto quiere decir que, por defecto, las únicas acciones que se pueden llevar a
cabo sobre objetos dentro de contenedores son las acciones coger y mirar por
defecto de AGE, el resto no funcionarán. Esto incluye también a las acciones que
se definan o redefinan mediante los métodos de análisis de la entrada vistos en
capítulos anteriores.

Sin embargo, si se quieren definir acciones que sí funcionen sobre objetos que
estén dentro de contenedores, también se puede hacer. Aunque no se recomienda
utilizar esta funcionalidad en general porque suele ser síntoma de un diseño con
contenedores innecesarios como se explicaba en la sección anterior, existe la
posibilidad de hacerlo. Para ello, en los menús del PUCK, cada uno de los
métodos de análisis de la entrada que hemos visto en los capítulos anteriores
tiene una versión que pone entre paréntesis (para contenedores y objetos
contenidos). Ésta es la versión que debemos seleccionar para definir acciones
que actúen directamente sobre cosas que estén dentro de contenedores.

Por ejemplo, supongamos que queremos que se pueda \comillas{cortar chorizo con
cuchillo} a pesar de que el chorizo esté en un contenedor (por ejemplo, una
tabla de cortar). Para ello, si queremos definir la acción en el chorizo
(también podríamos alternativamente hacerlo en el cuchillo), vamos a su campo de
código y, en los menús, seleccionamos Insertar código -- Redefinir métodos de
cosa -- Método de análisis de la entrada (para contenedores y objetos
contenidos) -- Referente a ésta y otra cosa, en ese orden. Obtenemos la
siguiente plantilla:

\begin{lstlisting}
/*Método de análisis sintáctico de la entrada referida a dos cosas, que pueden o no estar dentro de otras*/
/*Este método se ejecuta:
  - Cuando el jugador invoca una orden sobre dos objetos, el primero de los cuales es éste (estén o no estos objetos dentro de un contenedor).
  - Cuando el jugador invoca una orden sobre dos objetos, el primero de los cuales está contenido en éste.
*/
void parseCommandOnContentsObj1 ( Mobile aCreature , String verb , String args1 , String args2 , List path1 , List path2 ,  Entity obj2  )
{
 
	//aCreature: criatura que introduce un comando.
	//verb: comando que introduce, por ejemplo "afilar"
	//args1: parte de la orden que se refiere a un primer objeto, por ejemplo "el cuchillo". Ese primer objeto es éste o está contenido
		//en éste.
	//args2: parte de la orden que se refiere a un segundo objeto, por ejemplo "con el afilador"
	//path1: camino de contenedores desde el primer objeto al que referencia la orden. Por ejemplo, si introdujo "afilar el cuchillo con el
		//afilador" y el cuchillo está en una caja, será [cuchillo, caja].
	//path2: camino de contenedores desde el segundo objeto al que referencia la orden. Por ejemplo, si introdujo "afilar el cuchillo con el
		//afilador" y el afilador no está dentro de nada, será [afilador].
	//obj2: segundo objeto al que se refiere la acción del jugador (en el ejemplo, el objeto afilador).
 
 
	//terminar con end(): interceptamos la frase, no se ejecuta lo que se tenga que ejecutar
	//por defecto ante ella
	//terminar normal: después de nuestro procesado, se lleva a cabo el análisis normal del
	//comando y ejecución de la acción correspondiente
 
}
\end{lstlisting}

Los métodos de análisis de la entrada para contenedores y objetos contenidos se
parecen a sus análogos estándar vistos anteriormente, pero son más complejos. En
concreto, las diferencias son éstas:

\begin{enumerate}
\item {La primera es la diferencia obvia: el método no sólo se ejecutará cuando
el jugador teclee una acción referente al objeto en que lo definimos y éste esté
en el inventario del jugador o en el de la habitación en la que está éste; sino
también cuando el objeto esté en un contenedor que a esté en estos inventarios
(o bien en un contenedor que a su vez esté en otro contenedor que esté en estos
inventarios, etc.)}
\item {Además, el método se nos ejecutará tanto cuando el jugador teclee una
acción referente al objeto en que lo definimos (siempre que esté en uno de los
lugares dichos anteriormente) como cuando teclee una acción referente a un
objeto contenido en aquél en que lo definimos. Esto nos da la flexibilidad de
permitir capturar acciones sobre todo lo que esté contenido en un contenedor
(por ejemplo, que al coger cualquier objeto que esté dentro de un baúl, salte
una trampa en dicho baúl).}
\item {Los métodos de análisis para contenedores y objetos contenidos nos pasan
unos parámetros path que nos dan el camino completo de contenedores que va desde
el objeto al que se refirió el jugador hasta el contenedor más externo. Por
ejemplo, si el jugador ha puesto \comillas{cortar chorizo con cuchillo} y el
chorizo está en una caja que a su vez está dentro de un baúl, \textsf{path1}
sería una lista de longitud 3 tal que \textsf{path1.get(0)} sería el
\textsf{Item} chorizo, \textsf{path1.get(1)} sería la caja y
\textsf{path1.get(2)} sería el baúl. En ese mismo ejemplo, \textsf{path2} sería
una lista de longitud 1 que sólo contendría el cuchillo (si no está contenido en
nada).}
\item{Para obtener las entidades a las que realmente se refirió el jugador,
podemos utilizar \textsf{path1.get(0)} y \textsf{path2.get(0)}. Nótese que
\textsf{path1.get(0)} no necesariamente coincide con self (puede ser en su lugar
un objeto contenido en \textsf{self}, por razón de lo explicado en el punto 2).
Así pues, si queremos asegurarnos de definir una acción que afecte sólo al
objeto en el que se define y no a los que puedan estar contenidos en él,
tendríamos que hacer una comprobación tipo \textsf{equals(path1.get(0),self}).}
\end{enumerate}

El resto de métodos de análisis de la entrada para contenedores y objetos
contenidos se comportan análogamente a éste, teniendo dos parámetros tipo
\textsf{List} en el caso de métodos para dos entidades, o uno en el caso de
métodos para una entidad.

De este modo, podríamos definir la acción de cortar el chorizo con el cuchillo
de la siguiente manera (IMPORTANTE: no debe tomarse este ejemplo como
recomendación del autor de cómo hacer un juego, ya que el autor es de la opinión
de que este tipo de usos barrocos de los contenedores no se debería utilizar
nunca; pero lo incluye en esta documentación por completitud):

\begin{lstlisting}
void parseCommandOnContentsObj1 ( Mobile aCreature , String verb , String args1 , String args2 , List path1 , List path2 ,  Entity obj2  )
{
 
  if ( equals ( self , path1.get(0) ) ) //acción referida al chorizo
  {
    if ( equals ( path1.size() , 1 ) || !equals ( item("tabla") , path1.get(1) ) ) //si el chorizo no está en la tabla
    {
      aCreature.writeDenial("Para cortar el chorizo, deberías ponerlo en una tabla primero.\n");
      end(); 
    }   
    else if ( equals ( path2.get(0) , item("cuchillo") ) ) //si está en la tabla y cortamos con el cuchillo
    {
      if ( equals ( path2.size() , 1 ) ) //el cuchillo no está dentro de nada
      { 
        aCreature.writeAction("Cortas el chorizo con el cuchillo limpiamente sobre la tabla.\n");
        item("tabla").getInventory().removeItem(item("chorizo"));
        item("tabla").getInventory().addItem(item("chorizo troceado"));
        set ( item("tabla") , "manchadaDeChorizo" , true );
        end(); 
      } 
      else //el cuchillo está dentro de algo
      {
        aCreature.writeDenial("Primero tendrías que sacar el cuchillo de " + path2.get(1).getSingName(aCreature));
        end();  
      }   
    }
    else //si está en la tabla y no cortamos con el cuchillo
    {
      aCreature.writeDenial("Para cortar el chorizo, necesitarías un cuchillo.\n");
      end(); 
    }   
  } 
 
}
\end{lstlisting}

Si además quisiéramos mirar si la tabla está en una mesa, tendríamos que irnos
a mirar si el tamaño de \textsf{path1} es al menos 3 y si \textsf{path1.get(2)}
es la mesa, complicando más el código así como la vida del sufrido jugador.

\section{Miembros y prendas} \label{sec:MiembrosPrendas}

Una \textit{prenda} es una cosa que los jugadores y criaturas pueden vestir
en alguna parte de su cuerpo. Las prendas pueden tener propósito de
armadura (en los juegos que incluyan combates) o no tenerlo (en el resto de
los juegos). Así, ejemplos de objetos que se pueden modelar como prendas en
AGE podrían ser una cota de mallas, un traje, unos guantes, un guantelete,
unas botas o incluso un anillo o un pendiente.

Las prendas se ponen y se quitan por defecto mediante las órdenes
\textsf{vestir prenda} y \textsf{desvestir prenda}. En versiones actuales
de AGE (de 1.0.3 a 1.2.3), las órdenes \textsf{poner jugador prenda} (ponerse
prenda) y \textsf{coger jugador prenda} (quitarse/sacarse prenda) también
funcionan para ponerse y quitarse prendas. Sin embargo, es importante tener
en cuenta que estas últimas órdenes se eliminarán en el futuro, por lo que se
recomienda a los creadores de aventuras suponer que sólo existen por defecto
vestir y desvestir, y programarse en BeanShell los verbos poner y quitar si se
quiere que funcionen para este propósito.

Una prenda en AGE siempre se pone en una o varias partes del cuerpo, esto
permite crear un sistema de prendas realista (por ejemplo, si tenemos un
yelmo puesto no nos podremos poner otro a la vez, porque ambos ocuparían la
cabeza; pero sí que podemos tener puestos a la vez un yelmo y unas botas
porque el primero va en la cabeza y las segundas en los pies).

Así pues, el sistema de prendas en AGE va ligado al sistema de partes del
cuerpo (miembros), que es el que sirve para decidir qué prendas pueden
combinarse con otras. No obstante, si en un mundo de AGE no es necesario
este nivel de complejidad, se puede simplificar, como se verá más adelante.

\subsection {Miembros}

Los miembros son cosas que representan las partes del cuerpo de un jugador
o criatura. Con la funcionalidad por defecto del AGE, la utilidad de los
miembros es que sirven para blandir armas así como para vestir prendas y
armaduras. Por supuesto, el creador de aventuras puede dar otros usos a los
miembros programando en BeanShell si lo considera necesario.

Para definir un miembro, como por ejemplo la cabeza del jugador, la añadimos
en el PUCK como una cosa cualquiera, rellenando los campos (nombre único,
nombre de referencia, género, etc.) que sean necesarios. A continuación,
creamos una relación estructural que vaya del jugador a la cabeza. Por
defecto, la flecha resultante está etiquetada con la palabra \comillas{tiene}, que
quiere decir que la cabeza está en el inventario del jugador (como si éste
llevase una cabeza cortada consigo). Para ponerla como miembro, hacemos
click en la flecha de la relación, y en la ficha \comillas{Relación estructural}
del panel asociado cambiamos \comillas{tiene} por \comillas{se compone de}. De este modo,
la cabeza pasa a ser un miembro del jugador, tal y como queremos.

Es posible hacer que un miembro se componga de otros miembros (por ejemplo,
que una mano tenga varios dedos) creando relaciones \comillas{se compone de} entre
unos y otros. Sin embargo, esto no es necesario, al menos con la
funcionalidad por defecto del AGE. Si queremos tener anillos que se pongan
en los dedos, en la práctica es igualmente válido poner éstos como partes
del jugador en lugar de como partes de la mano; aunque un perfeccionista
del modelado pueda querer hacer lo segundo.

Cada criatura puede llevar a cabo acciones sobre sus propios miembros (por
ejemplo, vendarse el brazo izquierdo, suponiendo que definamos la respuesta
al verbo \comillas{vendar} adecuadamente en el brazo); pero por defecto no puede
llevar a cabo acciones sobre los miembros de los demás.

Si queremos trabajar con los miembros de alguna criatura desde código
BeanShell, podemos utilizar los siguientes métodos:

\begin{lstlisting}
/*clase Mobile*/ Inventory getPartsInventory()
\end{lstlisting}

Este método devuelve una lista de la clase \textsf{Inventory} que contiene
los miembros directos de la criatura sobre la que se invoca. Con directos
queremos decir que, si un brazo está modelado como parte de la criatura y a
su vez una mano como parte del brazo, la lista contendrá el brazo pero no
la mano.

Este inventario se puede modificar, añadiendo o quitando elementos para
añadir o quitar miembros dinámicamente a una criatura.

\begin{lstlisting}
/*clase Item*/ Inventory getParts()
\end{lstlisting}

Devuelve una lista de clase \textsf{Inventory} con las partes de la cosa
dada. En el ejemplo anterior, si lo invocáramos sobre el brazo, devolvería
un inventario conteniendo la mano.

Este inventario se puede modificar, añadiendo o quitando cosas para añadir
o quitar partes dinámicamente a un miembro.

\begin{lstlisting}
/*clase Mobile*/ Inventory getFlattenedPartsInventory()
\end{lstlisting}

Devuelve una lista de clase \textsf{Inventory} conteniendo los miembros
directos e indirectos de la criatura sobre la que se invoca. Es decir, en
el ejemplo anterior, este método devolvería una lista conteniendo tanto el
brazo como la mano.

Al contrario que los anteriores, este inventario es de \comillas{sólo lectura}. Si
se modifica, no tendrá el efecto de añadir ni quitar miembros a la criatura.

\subsection {Prendas} \label{sec:Prendas}

Como se explicó anteriormente, una prenda es una cosa que los jugadores
pueden vestir en alguna parte de su cuerpo. Para crear una prenda en PUCK,
lo hacemos de la siguiente manera:

\begin{itemize}
\item {Creamos una cosa en PUCK, rellenando todos los campos estándar de
nombres, género, descripción, etc.}
\item {Vamos a la ficha \comillas{Prenda} del panel de entidad de la cosa, y
marcamos la casilla \comillas{Es prenda}, indicando que efectivamente se trata de
una prenda.}
\item {A continuación, tenemos que especificar en qué miembro o miembros de
las criaturas se podrá llevar esa prenda. Por ejemplo, un casco se podrá
llevar en la cabeza. Para hacer esto, utilizamos el formulario llamado
\comillas{Miembros requeridos} de la ficha \comillas{Prenda}:}
\item {Pulsamos el botón \comillas{Añadir miembro}. Esto hace que nos aparezca un
nuevo panel de \comillas{Miembro}, que nos da la opción de añadir una serie de
nombres. Introducimos \comillas{cabeza}, y con esto, el casco ya tiene la
información de que puede ponerse en la cabeza.}
\end{itemize}

Si en lugar de un solo miembro, una prenda necesita ocupar varios (por
ejemplo, unas botas podrían ocupar el pie izquierdo y el pie derecho, si
los modelamos como objetos distintos); entonces le daremos varias veces al
botón \comillas{Añadir miembro}, y en cada uno de los paneles que aparezcan
introduciremos el nombre de uno de los miembros (por ejemplo, \comillas{pie
izquierdo} en uno, y \comillas{pie derecho} en el otro).

Por otra parte, si una misma prenda se puede poner en distintos tipos de
miembros (pero sólo en uno de cada vez), lo que haremos será darle a
\comillas{Añadir miembro} una sola vez; pero añadirle varios nombres: por ejemplo,
si un guante es reversible y puede encajar tanto en la mano derecha como en
la izquierda, podríamos poner \comillas{mano derecha} y \comillas{mano izquierda} como
nombres en su miembro requerido. Estos nombres siempre se procesan en orden,
es decir, si ponemos primero \comillas{mano derecha} y después \comillas{mano izquierda}
y el jugador teclea \textsf{vestir guante}, se colocará éste en la mano
derecha si la tiene libre, y sólo en el caso de que no la tenga libre se lo
pondrá en la izquierda.

Si queremos que una criatura comience el juego con una prenda puesta, lo
haremos creando en PUCK una relación llamada \comillas{wears} con valor
\textsf{true} que vaya del miembro correspondiente a la criatura. Por
ejemplo, si queremos que un jugador comience con un casco puesto en su
cabeza:

\begin{itemize}
\item {Creamos una relación (flecha) de la cabeza al casco,}
\item {Clickeamos en ella,}
\item {Vamos a la ficha \comillas{Otras relaciones} del panel de la relación,}
\item {Introducimos nombre \comillas{wears}, valor \textsf{true}, y tiempo restante
$-1$ (infinito).}
\end{itemize}

Si queremos modificar desde el código BeanShell las prendas que lleva
puestas o deja de llevar una criatura, basta con poner el valor de la
relación \comillas{wears} entre cada miembro y la correspondiente prenda a
\textsf{true} o \textsf{false} (véase cómo hacerlo en la sección de
relaciones). También podemos utilizar el mecanismo de relaciones para
consultar qué prendas lleva puesta una criatura y en qué miembros; pero
adicionalmente, AGE nos proporciona métodos para hacer esto más
rápidamente:

\begin{lstlisting}
/*clase Mobile*/ Inventory getWornItems()
\end{lstlisting}

Este método devuelve una lista de todas las prendas que lleva puesta la
criatura sobre la que se invoca. El inventario devuelto es de sólo lectura,
es decir, quitarle y ponerle cosas no tendrá ningún efecto sobre lo que
lleva puesta la criatura (para esto, debemos usar las relaciones).

\begin{lstlisting}
/*clase Mobile*/ Item getWornItem( Item limb )
\end{lstlisting}

Devuelve la prenda que lleva puesta la criatura sobre la que se invoca en
el miembro dado por limb o, si no lleva ninguna prenda, devuelve \textsf{null}.

\begin{lstlisting}
/*clase Mobile*/ boolean wearsItem( Item wearable )
\end{lstlisting}

Sirve para comprobar si la criatura sobre la que se invoca lleva o no
puesta la prenda dada como parámetro. Devuelve \textsf{true} si la lleva
puesta (en cualquiera de sus miembros) y \textsf{false} de lo contrario.

\section {Estados de las criaturas} \label{sec:EstadosCriaturas}

En la sección \ref{sec:Temporizacion} sobre temporización vimos cómo
funcionaba el modelo de tiempo de AGE, basado en unidades de tiempo y en
propiedades cuyo método update se activa cuando su contador de tiempo llega
a cero. En esa sección, vimos algunos ejemplos de cómo usar ese mecanismo
para definir entidades con comportamientos que dependieran del tiempo. Pero,
además de los que nosotros añadamos, en AGE ya existen comportamientos
definidos por defecto que dependen del tiempo, que son los asociados a las
acciones de las criatura, como coger un objeto o moverse en una dirección.
Todas las acciones que llevan a cabo las criaturas consumen un tiempo, y la
cuenta de este tiempo se lleva en el temporizador de una propiedad llamada
\comillas{state}.

Por ejemplo, como jugadores, cuando AGE nos acepta una orden de entrada, es
porque ha llegado a cero el temporizador de \comillas{state} de nuestro personaje
jugador. Si tecleamos \comillas{ir norte}, AGE cambiará el valor de \comillas{state} a un
valor de estado (que se verá más adelante) que indica que nos estamos
moviendo, y fijará el temporizador al número de unidades de tiempo que nos
consuma ir hacia el norte. Una vez llegado el temporizador a cero, esto
significa que ya hemos terminado de ir hacia el norte y AGE esperará otra
orden de entrada, que de nuevo cambiará el valor y temporizador de \comillas{state},
y así sucesivamente.

Por lo tanto, el método \textsf{update} que define AGE por defecto para la
propiedad \comillas{state} de los jugadores es muy importante, porque es nada menos
que el que consigue que al ejecutar una aventura monojugador, ésta nos vaya
pidiendo órdenes y ejecutándolas una por una. En una aventura multijugador
o que cuente con personajes complejos que realicen acciones, el temporizador
de esta propiedad será el que se encargue de entrelazar correctamente las
acciones: por ejemplo, si ir al norte desde una localidad a otra consume
tres unidades de tiempo y coger un objeto consume una unidad de tiempo, el
jugador A podrá coger tres objetos en el tiempo en el que el jugador B va al
norte (la manera concreta en la que los jugadores perciben esto en los modos
síncrono y de tiempo real se trató en la sección de temporización).

En la presente sección veremos en detalle cómo funciona esta propiedad
especial \comillas{state} (y otra asociada, llamada \comillas{target}) y qué podemos hacer
con ellas.

\subsection{Las propiedades \comillas{state} y \comillas{target}} \label{sec:StateTarget}

Las criaturas (objetos de la clase \textsf{Mobile}) tienen una propiedad
especialmente importante llamada \comillas{state} (estado). La importancia de la
propiedad \comillas{state} radica en que esta propiedad es la que define qué cosa
está haciendo una criatura en cada momento, y su temporizador es el que
indica cuánto tiempo tardará en hacerlo.

Asociada a la propiedad \comillas{state} aparece a veces otra propiedad, llamada
\comillas{target}, que nos proporciona información extendida sobre el estado. Así,
por ejemplo, si en un instante dado del juego la criatura Pepito está yendo
de la sala sur a la sala norte, su propiedad \comillas{state} en ese momento valdrá
\textsf{Mobile.MOVING} (valor que indica que se está moviendo) y su
propiedad \comillas{target} contendrá un identificador de la sala norte.\footnote{Por
motivos puramente históricos, el identificador contenido en \comillas{target} es
un número entero en lugar del nombre único de la sala. Sin embargo, se puede
utilizar igual que si fuera el nombre único (es decir, funcionarán cosas
como \textsf{room(fulano.get("target"))}. Probablemente la propiedad
\comillas{target} pase a contener nombres únicos, en lugar de dichos identifiadores
enteros, en futuras versiones de AGE.}

El manejo de las propiedades \comillas{state} y \comillas{target} ha de considerarse un
tema avanzado, pues en la mayoría de los juegos no hace falta manipularlas.
Sólo debería ser necesario en aventuras en las que se quiera tener un
control fino del combate o de la temporización de eventos.

En la siguiente tabla se muestran los valores que puede tomar, para
cualquier criatura, la propiedad \comillas{state}, así como su significado y el uso
de la propiedad \comillas{target} para ese estado. Nótese que gran parte de los
estados, aunque no todos, están relacionados con el combate y se tratarán
en más detalle en la sección \ref{sec:CombateArmas} Combate y armas de esta
documentación.
\\
{\footnotesize\begin{tabular}{|l|p{6cm}|p{2.5cm}|}
\hline
\textbf{Valor de \comillas{state}} & \textbf{Significado de \comillas{state}} & \textbf{Significado de \comillas{target}} \\
\hline
\hline
\textsf{Mobile.IDLE} & Estado por defecto. Ojo: el nombre (\textsf{IDLE},
												ocioso) está mal puesto, pues no tiene por qué
												significar que la criatura esté ociosa. Se puede
												utilizar para denotar que la criatura está llevando
												a cabo cualquier acción no contemplada en los otros
												estados. Por ejemplo, es el estado que tiene una
												criatura que está cogiendo o dejando un objeto.  &  \\
\hline
\textsf{Mobile.MOVING } & La criatura está moviendose de una habitación a
													otra. El temporizador de \comillas{state} indica cuántas
													unidades de tiempo quedan hasta que se complete el
													movimiento. En el momento en que se completa es
													cuando la criatura cambia realmente de habitación,
													y se imprimen los mensajes como \comillas{Fulano se va al
													norte} o \comillas{Fulano llega desde el sur}. & Habitación destino \\
\hline
\textsf{Mobile.ATTACKING} & La criatura está lanzando un ataque contra otra
														criatura. Cuando el temporizador llegue a cero,
														el ataque impactará al enemigo (si no ha
														sucedido antes algo que lo impida, como que la
														criatura reciba un golpe). & Criatura que recibirá el ataque \\
\hline
\textsf{Mobile.BLOCKING} & La criatura está preparando un bloqueo. Cuando el
														temporizador llegue a cero, la criatura pasará
														a estar \comillas{en guardia} (\textsf{Mobile.READY\_TO\_BLOCK})
														y si le llega un ataque, será bloqueado. & \\
\hline
\textsf{Mobile.READY\_TO\_BLOCK} & La criatura está bloqueándose, con un
														escudo o arma alzada para parar un ataque enemigo. & \\
\hline
\textsf{Mobile.DODGING} & La criatura está echándose a un lado para intentar
														esquivar un ataque. Si el temporizador llega a
														cero antes de que se reciba el ataque, se
														considerará que le ha dado tiempo a esquivar. & \\
\hline
\textsf{Mobile.READY\_TO\_DODGE} & La criatura está echándose a un lado para
														intentar esquivar un ataque, y ha pasado el
														tiempo suficiente para considerar que le da
														tiempo a esquivar, sin que el ataque haya
														llegado. & \\
\hline
\textsf{Mobile.ATTACK\_RECOVER} & La criatura está recuperándose después de
														haber lanzado una estocada o golpe. Hasta que el
														temporizador del \comillas{state} llegue a cero, no
														podrá emprender otra acción. & \\
\hline
\textsf{Mobile.BLOCK\_RECOVER} & La criatura está recuperándose después de
														haber parado un golpe. Hasta que el temporizador
														del \comillas{state} llegue a cero, no podrá emprender
														otra acción. & \\
\hline
\textsf{Mobile.DAMAGE\_RECOVER} & La criatura está recuperándose después de
														haber recibido un golpe. Hasta que el
														temporizador del \comillas{state} llegue a cero, no
														podrá emprender otra acción. & \\
\hline
\textsf{Mobile.DODGE\_RECOVER} & La criatura está recuperándose después de
														haber llevado a cabo una esquivada con éxito.
														Hasta que el temporizador del \comillas{state} llegue a
														cero, no podrá emprender otra acción. & \\
\hline
\textsf{Mobile.DYING} & La criatura está cayendo muerta. Este estado siempre
														dura una unidad de tiempo nada más, y luego se
														pasa al estado \textsf{Mobile.DEAD}. & \\
\hline
\textsf{Mobile.DEAD} & La criatura está muerta. & \\
\hline
\textsf{Mobile.SURPRISE\_RECOVER} & La criatura está recuperándose de una
														sorpresa o interrupción. & \\
\hline
\textsf{Mobile.DISABLED} & La criatura está desactivada y no reaccionará
														ante nada, ni recibirá entradas si es un jugador.
														Este estado se usa, por ejemplo, cuando el
														jugador que controlaba un personaje en una
														aventura multijugador se ha caído o desconectado. & \\
\hline
\textsf{Mobile.CASTING} & La criatura está lanzando un conjuro. & Entidad a la que se le lanza el hechizo, si la hay \\
\hline
\end{tabular}}

\subsection{Cambios de estado}

He aquí lo que sucede por defecto en AGE cuando el temporizador del estado
de una criatura llega a cero, a no ser que nosotros como programadores
redefinamos el método update para que haga algo distinto con la propiedad
\comillas{state}: 

{\footnotesize\begin{tabular}{|l|p{8cm}|}
\hline
\textbf{Valor de \comillas{state}} & \textbf{Reacción de las criaturas} \\
\hline
\hline
\textsf{Mobile.IDLE} & Tomar decisión \\
\hline
\textsf{Mobile.MOVING} & Tomar decisión \\
\hline
\textsf{Mobile.ATTACKING} & Se lleva a cabo el ataque y se pasa a \textsf{Mobile.ATTACK\_RECOVER} \\
\hline
\textsf{Mobile.BLOCKING} & Se pasa a \textsf{Mobile.READY\_TO\_BLOCK} \\
\hline
\textsf{Mobile.READY\_TO\_BLOCK} & Se refresca el estado hasta que llegue el ataque enemigo, y en ese momento se pasa a \textsf{BLOCK\_RECOVER} o \textsf{DAMAGE\_RECOVER} según el resultado \\
\hline
\textsf{Mobile.DODGING} & Se pasa a \textsf{Mobile.READY\_TO\_DODGE} \\
\hline
\textsf{Mobile.READY\_TO\_DODGE} & Se refresca el estado hasta que llegue el ataque enemigo, y en ese momento se pasa a \textsf{DODGE\_RECOVER} o \textsf{DAMAGE\_RECOVER} según el resultado \\
\hline
\textsf{Mobile.ATTACK\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.BLOCK\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DAMAGE\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DODGE\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DYING} & Se pasa a \textsf{Mobile.DEAD} \\
\hline
\textsf{Mobile.DEAD} & Se mantiene el estado \\
\hline
\textsf{Mobile.SURPRISE\_RECOVER} & Tomar decisión \\
\hline
\textsf{Mobile.DISABLED} & Se mantiene el estado \\
\hline
\textsf{Mobile.CASTING} & Se pasa a \textsf{IDLE} \\
\hline
\end{tabular}}

Los casos en los que esta tabla dice \comillas{Tomar decisión} quiere decir que la
criatura tiene la iniciativa y puede en ese momento emprender una nueva
acción. Esto tiene un significado distinto según si la criatura es un
jugador o no:

\begin{itemize}
\item {Si se trata de un jugador, cuando llegue el momento de \comillas{Tomar
decisión} se esperará una orden por parte del cliente del jugador, y se
procesará dicha orden, ejecutando los comportamientos correspondientes.}
\item {Si se trata de una criatura que no es jugador, cuando llegue el
momento de \comillas{Tomar decisión} se hará lo siguiente:
	\begin{itemize}
	\item {Si tiene enemigos presentes, se llama a la IA de combate que decide
	qué acción de combate tomará la criatura (atacar, bloquear, etc.)}
	\item {Si no tiene enemigos presentes, la criatura simplemente no hará
	nada, quedando indefinidamente en estado \textsf{Mobile.IDLE}.}
	\end{itemize}}
\end{itemize}

Por supuesto, podemos sobreescribir el método update de los personajes no
jugadores definiendo comportamientos más complejos, y así obtener criaturas
que se muevan, sigan rutas, cojan objetos, desempeñen tareas, etc.

\subsection {Programación con estados}\label{sec:prog-estados}

Como programadores de aventuras, el uso más evidente de la propiedad \comillas{state}
es el de comprobar lo que está haciendo una criatura. Por ejemplo, si
queremos saber si un personaje llamado Manolo que está en nuestra habitación
ha empezado a irse hacia otra, podríamos hacer algo como:

\begin{lstlisting}
if ( equals ( get(mobile("Manolo"),"state") , Mobile.MOVING ) )
{
  self.say("¡No te vayas aún, Manolo, que todavía me quedan cosas que contarte!\n");
}
\end{lstlisting}

Además, con \textsf{room(get(mobile("Manolo"),"target"))} podemos obtener la
habitación a la que se está moviendo Manolo, y con
\textsf{getTime(mobile("Manolo"),"state")} tendremos el número de unidades
de tiempo que le faltan para llegar a ella (véase la sección
\ref{sec:Temporizacion} sobre temporización).

Aparte de utilizar la propiedad \comillas{state} para comprobar el estado de una
criatura, los programadores más osados pueden querer redefinir lo que sucede
en el método update para la propiedad \comillas{state} y de ese modo cambiar la
manera en la que se comporta una criatura en los cambios de estado. Estos
cambios pueden potencialmente ir desde modificaciones puntuales hasta
cambios radicales que, por ejemplo, modifiquen totalmente la manera en la
que se resuelven los cambios de estado tipo \comillas{Tomar decisión} cambiando
todo el sistema de parseado de AGE por otro sistema totalmente distinto.
Por supuesto, sólo los programadores avanzados o con mucha práctica en AGE
y con interés en personalizarlo deberían utilizar estas características,
que no son para nada necesarias para hacer un buen juego con AGE.

\section {Combate y armas} \label{sec:CombateArmas}

Aetheria Game Engine fue pensado inicialmente como sistema para crear juegos
de rol de texto mono y multijugador, y por ello cuenta con un completo
sistema para simular combates. Por supuesto, este sistema se puede obviar y
no utilizar, de ahí que AGE también sirva perfectamente para crear juegos de
aventura sin elementos de rol y que, de hecho, la mayoría de los juegos
creados hasta hoy en AGE sean de este último tipo. Sin embargo, para quien
esté interesado en hacer que su mundo permita emocionantes duelos a espada
contra orcos, será interesante leer esta sección.

El sistema de combate de AGE está pensado fundamentalmente para combate
estilo medieval y de fantasía, con armas cuerpo a cuerpo y magia. Sin
embargo, al tratarse de un sistema muy genérico, también es posible
adaptarlo a otras situaciones como pueden ser tiroteos con armas de fuego.

El combate en AGE está fuertemente basado en el sistema de temporización (ver
sección \ref{sec:Temporizacion}), así como en los estados de las criaturas
(ver sección \ref{sec:EstadosCriaturas}). Si no recuerdas bien el contenido
de esas dos secciones, es recomendable echarles un vistazo antes de seguir
con ésta.

\subsection {Elementos de rol básicos}

\subsubsection {Puntos de vida y daño}

Como la inmensa mayoría de los juegos de rol por ordenador (CRPG's), el
sistema de combate de AGE utiliza el modelo de recuento del daño por el cual
una criatura cuenta con un determinado número de \textit{puntos de golpe} o
\textit{puntos de vida} (abreviados como HP, del inglés \comillas{hit points}).
Cuando la criatura recibe daño, por ejemplo por ser golpeada con un arma,
pierde puntos de vida (y a los puntos de vida que se restan de su cifra
total se les llama \textit{puntos de daño}). Los puntos de vida, pues, miden
el nivel de salud que le queda a una criatura, y si en algún momento llegan
a cero o menos, la criatura muere.

Por ejemplo, supongamos que un jugador tiene diez puntos de vida. Si un orco
le ataca con un hacha infligiéndole seis puntos de daño, estos puntos de
daño se restan de sus diez puntos de vida, y por lo tanto el jugador se
queda con sólo cuatro puntos de vida. Si a continuación el orco vuelve a
atacarle y esta vez le inflige siete puntos de daño, el jugador se queda con
$4-7=-3$ puntos de vida. Como esta cantidad de puntos de vida es menor o
igual (en este caso menor) que cero, el jugador muere.

En AGE, podemos definir cuántos puntos de vida tiene una criatura mediante
el panel de criatura de PUCK:

\begin{itemize}
\item {Si hacemos click en una criatura en el mapa de PUCK, en la pestaña
\comillas{General} hay un campo del formulario etiquetado \comillas{HP}. Este campo nos
permite definir la cantidad de puntos de vida con la que empieza la
criatura.}
\item {El campo etiquetado \comillas{HP máx}, situado al lado de \comillas{HP}, nos
permite definir la cantidad de puntos de vida máximos de la criatura (es
decir, la cantidad de puntos de vida que tiene la criatura cuando está
saludable y no ha recibido ningún daño).}
\end{itemize}

Así pues, si ponemos la misma cifra en el campo \comillas{HP} que en el campo
\comillas{HP máx}, esto significará que la criatura está inicialmente saludable. Si
ponemos una cifra menor en \comillas{HP} que en \comillas{HP máx}, significará que la
criatura ya comienza con algún daño.

Tanto \comillas{HP} como \comillas{HP máx} deben tener inicialmente un valor mayor que
cero. No hay límite superior (al menos mientras no te pases de un par de
miles de millones), así que puedes usar distintas escalas: puedes preferir
un mundo donde las criaturas tengan pocos puntos de vida (que un hombre
fuerte tenga diez, y un golpe impresionante haga cinco puntos de daño) o
donde tengan muchos (que un hombre tenga mil puntos de vida, y un golpe
pueda hacer fácilmente doscientos de daño). Lo importante para el
programador será equilibrar su juego de forma que el combate resulte
realista, es decir, que el daño que hacen las armas guarde una buena
proporción con la vida que tienen las criaturas.

Los puntos de vida también se pueden obtener y modificar dinámicamente
mediante código BeanShell:

\begin{lstlisting}
/*clase Mobile*/ int getHP ( )
\end{lstlisting}

Devuelve la cantidad de puntos de vida que tiene actualmente la criatura
sobre la que se invoca.

\begin{lstlisting}
/*clase Mobile*/ void setHP ( int newHP )
\end{lstlisting}

Cambia la cantidad de puntos de vida que tiene la criatura sobre la que se
invoca a la cantidad newHP.

\begin{lstlisting}
/*clase Mobile*/ int getMaxHP ( )
\end{lstlisting}

Devuelve la cantidad de puntos de vida máximos de la criatura sobre la que
se invoca.

\begin{lstlisting}
/*clase Mobile*/ void setMaxHP ( int newMaxHP )
\end{lstlisting}

Cambia la cantidad de puntos de vida máximos que tiene la criatura sobre la
que se invoca a la cantidad \textsf{newMaxHP}. Esto se puede utilizar, por
ejemplo, para implementar subidas de nivel en juegos de rol basados en
niveles. Este método estará disponible a partir de la versión 1.1.7 de AGE.

\subsubsection {Atributos y habilidades}

Otro elemento típico en muchos juegos de rol son los \textit{atributos} y las
\textit{habilidades}.

Los atributos son valores numéricos que describen características físicas e
intelectuales genéricas de un personaje. Por ejemplo, atributos que se
suelen utilizar a menudo en juegos de rol son \comillas{fuerza}, \comillas{constitución},
\comillas{destreza}, \comillas{inteligencia} o \comillas{carisma}.

Las habilidades, por otra parte, son valores numéricos que describen la
práctica o el talento que un personaje tiene para realizar alguna actividad
específica. Ejemplos de posibles habilidades serían \comillas{espada}, \comillas{trepar},
\comillas{pescar}, \comillas{violín} o \comillas{diplomacia}.

AGE proporciona, por un lado, un sistema genérico para gestionar los valores
de los atributos y habilidades, que es muy sencillo y prácticamente no hace
nada más que almacenar los valores y permitirnos cambiarlos. Por otra parte,
AGE también proporciona mecánicas específicas asociadas a habilidades de
combate y magia.

Esto quiere decir que AGE nos proporciona toda la infraestructura necesaria
para utilizar las habilidades y atributos en el combate: por ejemplo, el
hecho de que la probabilidad de acertar en un ataque con un arma y el tiempo
que nos consume el ataque dependan de nuestra habilidad con esa arma, o el
hecho de que el utilizar repetidamente el arma haga que nuestra habilidad
con ella aumente con el tiempo. Veremos más detalles sobre esto en las
siguientes secciones.

Por otra parte, si queremos utilizar las habilidades y atributos para
funcionalidad no relacionada con el combate (como podría ser usar una
habilidad de \comillas{violín} para determinar si un personaje cautiva a su
audiencia en un concierto o no); AGE sólo nos proporciona la infraestructura
básica para almacenar y obtener los valores de esas habilidades y atributos,
el resto (por ejemplo, el código para decidir si el personaje consigue tocar
una pieza determinada o no según su habilidad con el violín) tendremos que
ponerlo nosotros como programadores de aventuras.

La mencionada infraestructura básica para almacenar y obtener valores de
habilidades y atributos consiste en un formulario de PUCK y una serie de
métodos invocables desde código BeanShell.

El formulario es la ficha de \comillas{Características} del panel asociado a un
personaje, y nos permite fijar los valores iniciales de habilidades y
atributos para ese personaje. Para ello, escribimos el nombre de la
habilidad o atributo (por ejemplo, \comillas{violín}) en el campo \comillas{Nombre} y su
valor numérico (por ejemplo, 30) en el campo \comillas{Valor}, y pulsamos el botón
\comillas{Añadir}. Si queremos rectificar el nombre y valor de un atributo, podemos
hacerlo seleccionándolo en la lista, modificando los datos en los campos
\comillas{Nombre} y \comillas{Valor}, y pulsando \comillas{Cambiar}.

Adicionalmente, AGE proporciona los siguientes métodos en la clase Mobile
para manipular atributos y habilidades:

\begin{lstlisting}
/*clase Mobile*/ int getStat ( String name )
\end{lstlisting}

Devuelve el valor numérico del atributo de nombre dado, por ejemplo
\textsf{mobile("manolo").getStat("inteligencia")} devolverá la inteligencia
de Manolo. Nótese que, si no hemos asignado ningún valor a un atributo, este
método devolverá por defecto un valor de 12 (el tradicional valor por
defecto de los atributos en juegos basados en Dungeons \& Dragons).

\begin{lstlisting}
/*clase Mobile*/ void setStat ( String name , int value )
\end{lstlisting}

Cambia el valor numérico del atributo de nombre \textsf{name} por el nuevo
valor \textsf{value}.

\begin{lstlisting}
/*clase Mobile*/ long getSkill ( String name )
\end{lstlisting}

Devuelve el valor numérico de la habilidad de nombre dado, por ejemplo
\textsf{mobile("manolo").getStat("violín")} devolverá la habilidad de
Manolo para tocar el violín. En este caso, si no se había fijado el valor de
esa habilidad, el valor devuelto por defecto será 0 (¡nadie sabe tocar el
violín sin aprender!)

\begin{lstlisting}
/*clase Mobile*/ void setSkill ( String name , long value )
\end{lstlisting}

Cambia el valor numérico de la habilidad de nombre \textsf{name} por el
nuevo valor \textsf{value}.

Nótese que, aunque los atributos y habilidades no están implementados como
propiedades, se comportan de manera muy similar a éstas. De hecho, para
implementar una habilidad que afecte a alguna actividad externa al combate,
se podría implementar igualmente con una propiedad. Para las relacionadas
con el combate, sin embargo, es necesario emplear este sistema de
habilidades y atributos si se quiere aprovechar toda la funcionalidad de
combate que se describirá más abajo.

\subsection {Mecánica de combate}

El sistema de combate en AGE funciona, grosso modo, de la siguiente manera:

\begin{itemize}
\item {Por defecto, existen tres acciones de combate en AGE: ataques,
bloqueos y esquivadas. Por supuesto, esto no excluye que durante un combate
se puedan perfectamente llevar a cabo otras acciones, como coger cosas, usar
objetos, lanzar hechizos, hablar con el adversario, o cualquier otra cosa
que esté definida en la aventura.}
\item {En un ataque, un personaje A ataca con un arma a un personaje B que
está en su misma habitación. Nótese que cada ataque es, pues, individual de
un personaje a otro, pero eso no quiere decir que los combates tengan que
ser uno contra uno (podría haber dos personajes A y C atacando a B a la vez,
por ejemplo). El ataque consume una cantidad de unidades de tiempo (durante
las cuales el arma está moviéndose para golpear al personaje B), y cuando
transcurren esas unidades de tiempo, se resuelve.}
\item {En un bloqueo, un personaje B intenta defenderse con un arma (nótese
que los escudos cuentan como armas) de un personaje A que lo está atacando.
Para ello, es necesario que A esté lanzando un ataque que todavía no se haya
resuelto (el arma está moviéndose para golpear a B). El bloqueo también
consume una determinada cantidad de unidades de tiempo (la que tarda B en
poner su arma en posición de bloquear el arma de A). Si B es capaz de hacer
esto antes de que llegue el arma de A, se resolverá el ataque con bloqueo,
dando oportunidad a B de defenderse (según su habilidad para hacerlo). Por
otra parte, si el arma de A llega antes de que B sea capaz de colocarse en
posición de bloqueo, el ataque de A se resolverá como si B no hubiera
bloqueado en absoluto.}
\item {En una esquivada, un personaje B intenta quitarse del medio ante un
ataque de un personaje A. De nuevo, es necesario que A esté lanzando un
ataque que todavía no se haya resuelto; y la esquivada consumirá una
determinada cantidad de unidades de tiempo (la que tarda B en apartarse del
paso). Si B es capaz de esquivar antes de que llegue el ataque de A, se
resolverá el ataque con esquivada, dando oportunidad a B de esquivar (según
su habilidad para ello). Por otra parte, si el arma de A llega antes, el
ataque de A se resolverá como si B no hubiera esquivado en absoluto.}
\item {Así, cuando se resuelve un ataque pueden pasar las siguientes cosas:
	\begin{enumerate}
	\item {Que el golpe de A sea fallido, y por lo tanto no impacte a B.}
	\item {Que el golpe de A sea bueno, pero B llegue a tiempo para esquivar y
	esquive con éxito, por lo tanto el ataque no impactará a B y éste no
	recibirá daño.}
	\item {Que el golpe de A sea bueno, y B llegue a tiempo para esquivar pero
	su esquivada sea fallida (se lanzó hacia el lado equivocado o lo hizo
	mal), con lo cual el ataque le impactará igual y B recibirá daño.}
	\item {Que el golpe de A sea bueno, pero B llegue a tiempo para bloquear y
	bloquee con éxito, con lo cual el ataque le impacta pero el bloqueo
	absorbe todo o parte del daño.}
	\item {Que el golpe de A sea bueno, y B llegue a tiempo para bloquear,
	pero su bloqueo sea fallido (no colocó el arma o escudo bien para detener
	el golpe de A), con lo cual el ataque le impactará como si no hubiera
	bloqueado y recibirá todo el daño.}
	\end{enumerate}}
\item {Todas estas acciones tienen además un \comillas{tiempo de recuperación}
después de que se produzcan: por ejemplo, después de lanzar un ataque, el
personaje que ha atacado estará unos instantes sin poder hacer otra cosa,
porque lógicamente volver a posicionar el brazo y el arma para lanzar otra
estocada o bloqueo consume un tiempo. Asimismo, el bloqueo y la esquivada
tienen un tiempo de recuperación, y también existe otro tiempo de
recuperación (que normalmente será mayor) al recibir un golpe, ya que lo
normal es que alguien que sufre un ataque en combate quede aturdido durante
unos instantes hasta que pueda reaccionar de nuevo.}
\end{itemize}

A la luz de esta descripción, si quieres (aunque no es realmente necesario
para implementar combates, si no quieres hacer cosas avanzadas) puedes
volver a mirar los estados relacionados con el combate presentes en la tabla
de la sección \ref{sec:StateTarget} sobre Las propiedades \comillas{state} y
\comillas{target} de las criaturas. Como comprobarás, dichos estados se usan para
implementar lo que acabamos de describir:

\begin{itemize}
\item {Cuando el personaje A lanza su ataque con un arma, se pone en estado
\textsf{Mobile.ATTACKING}, y su propiedad \comillas{target} apunta al personaje B.}
\item {Si el personaje B decide bloquear, se pondrá en estado
\textsf{Mobile.BLOCKING}.}
\item {Si B consigue ponerse en posición de bloqueo antes de que llegue el
ataque de A, se pondrá en estado \textsf{Mobile.READY\_TO\_BLOCK}.}
\item {Si el personaje B decide esquivar, se pondrá en estado
\textsf{Mobile.DODGING}.}
\item {Si a B le da tiempo a eludir el golpe antes de que llegue el ataque
de A, se pondrá en estado \textsf{Mobile.READY\_TO\_DODGE}.}
\item {Cuando se resuelva el ataque de A (es decir, el temporizador de su
propiedad \comillas{state} llegue a 0), se resolverá de forma diferente si el
estado de B es \textsf{Mobile.READY\_TO\_BLOCK}, \textsf{Mobile.READY\_TO\_DODGE}
u otra cosa. En los dos primeros casos, habrá que hacer \comillas{tiradas de dados}
con las habilidades para ver si el personaje B es capaz de bloquear o
esquivar. En el tercer caso, sólo se resolverá el ataque de A sin ningún
movimiento mitigador por parte de B.}
\item {Los estados \textsf{Mobile.ATTACK\_RECOVER}, \textsf{Mobile.BLOCK\_RECOVER},
\textsf{Mobile.DODGE\_RECOVER} y \textsf{Mobile.DAMAGE\_RECOVER}
corresponden a los tiempos de recuperación descritos anteriormente para
después de atacar, bloquear, esquivar y recibir un golpe, respectivamente.
Hasta que terminen estos estados, los personajes no podrán ejecutar una
nueva acción.}
\end{itemize}

Pero en esta descripción todavía faltan varios cabos sueltos por explicar,
concretamente:

\begin{itemize}
\item {Cómo funciona eso de las armas,}
\item {Cómo se decide cuántas unidades de tiempo exactamente consume cada
acción (ataques, bloqueos, esquivadas) así como cuántas unidades de tiempo
consumen los tiempos de recuperación,}
\item {Cómo se decide cuándo un ataque, un bloqueo y una esquivada tienen
éxito y cuándo no,}
\item {Cómo se decide cuánto daño se hace, y cuánto absorbe un bloqueo.}
\end{itemize}

Una respuesta rápida y resumida a los tres últimos cabos sueltos es que AGE
calcula estos tres resultados usando una combinación de tres tipos de
factores: factores dados por el arma, factores dados por las habilidades y
atributos del jugador que maneja el arma, y por último factores aleatorios
que sirven para dotar de un cierto grado de incertidumbre e
imprevisibilidad al combate. Todos estos factores se explican en la
siguiente sección, que trata de las armas.

\subsection {Armas}

Un \textit{arma} es cualquier cosa (de la clase \textsf{Item}) que un
personaje puede utilizar para lanzar y/o bloquear ataques. Para crear un
arma en PUCK, empezaremos creando una cosa de forma normal, con sus nombres,
descripciones y demás valores que ya conocemos. Para indicar que se trata de
un arma, seleccionaremos la pestaña \comillas{Arma} de su panel de entidad, y
activaremos la casilla etiquetada \comillas{Es arma}, que indica que la cosa es un
arma. El resto del formulario de la pestaña \comillas{Arma} nos permitirá
configurar en detalle el arma, como explicaremos en el resto de esta
sección.

\subsubsection {Usar y blandir armas}

Una primera cosa a tener en cuenta es que existen dos tipos de armas según
la manera en que funcionan: armas naturales y armas externas. Las armas
naturales son partes del cuerpo de una criatura que ésta puede usar como
arma (como por ejemplo un puño, que sirve para dar puñetazos). Las armas
externas, las más comunes, son objetos o herramientas que se usan como
armas, como puede ser una espada, un hacha o un escudo.

Para que una cosa funcione como arma natural, necesitaremos definirla como
miembro de una criatura (véase la sección sobre miembros para recordar cómo
se hacía esto). AGE interpreta automáticamente que cualquier cosa que esté
marcada como arma (casilla \comillas{Es arma}) y sea un miembro de una criatura es
un arma natural. Por otra parte, cualquier cosa que esté marcada como arma
pero no sea un miembro de una criatura funcionará como arma externa.

Para utilizar un arma externa, un personaje debe blandirla, cosa que ocupará
uno o varios de sus miembros: por ejemplo, una daga se puede blandir en una
mano, mientras que una espada de dos manos se podrá blandir --como su nombre
indica-- ocupando ambas manos. El sistema para blandir y enfundar armas es
totalmente análogo al sistema visto en la sección \ref{sec:Prendas} de
prendas para vestir y desvestir prendas, es decir:

\begin{itemize}
\item {Las armas se blanden y enfundan con las órdenes \textsf{blandir arma}
y \textsf{enfundar arma}, que funcionan de manera análoga a
\textsf{vestir prenda} y \textsf{desvestir prenda}.}
\item {Al igual que las prendas, las armas ocupan miembros, de forma que no
puede haber varias armas ocupando a la vez el mismo miembro (si blandimos
una espada en la mano derecha, no podemos blandir a la vez un hacha en la
misma mano).}
\item {El formulario \comillas{Miembros requeridos} de la pestaña Arma de PUCK
funciona exactamente igual que el de la pestaña Prenda, sólo que en este
caso se refiere a miembros requeridos para blandir un arma en lugar de para
vestir una prenda. Por supuesto, esto incluye la posibilidad de que un arma
ocupe varios miembros, y la de que un arma pueda ocupar distintos tipos de
miembros.}
\item {Si queremos que una criatura comience el juego blandiendo un arma,
se hace de forma análoga a cuando hacíamos que comenzara con una prenda
puesta, pero en este caso utilizamos una relación \comillas{wields} en vez de
\comillas{wears}. Es decir, debemos crear una relación \comillas{wields} que vaya del
miembro en el que se blande el arma al arma en sí, con valor \textsf{true} y
temporizador $-1$ (además de meter el arma en el inventario).}
\item {Podemos comprobar si una criatura está blandiendo algo en un miembro
comprobando el valor de esta relación \comillas{wields}, y hacer que blanda o deje
de blandir un arma modificándolo con los métodos de AGE para manipular
relaciones. Como en el caso de las prendas, AGE también nos proporciona una
serie de métodos que podemos invocar desde BeanShell para saber qué está
blandiendo una criatura de una forma más directa que usando relaciones:}
\end{itemize}

\begin{lstlisting}
/*clase Mobile*/ Inventory getWieldedWeapons()
\end{lstlisting}

Este método devuelve una lista de todas las armas que está blandiendo la
criatura sobre la que se invoca. El inventario devuelto es de sólo lectura,
es decir, quitarle y ponerle cosas no tendrá ningún efecto sobre lo que
lleva puesta la criatura (para esto, debemos usar las relaciones).

\begin{lstlisting}
/*clase Mobile*/ Item getWieldedItem( Item limb )
\end{lstlisting}

Devuelve el arma que lleva blandida la criatura sobre la que se invoca en el
miembro dado por \textsf{limb} o, si no lleva ningún arma ahí, devuelve
\textsf{null}.

\begin{lstlisting}
/*clase Mobile*/ boolean wieldsItem( Item item )
\end{lstlisting}

Sirve para comprobar si la criatura sobre la que se invoca está blandiendo
el arma dada como parámetro. Devuelve \textsf{true} si la lleva blandida (en
cualquiera de sus miembros) y \textsf{false} de lo contrario.

Hasta aquí, hemos visto cómo hacer que los jugadores y criaturas puedan
blandir y enfundar armas. Pero, por supuesto, lo más importante de las armas
es... ¡combatir con ellas!

\subsubsection {Parámetros de combate de las armas} \label{sec:ParamCombArmas}

Los parámetros de combate de las armas se definen en la mitad inferior de la
pestaña \comillas{Arma}, donde hay un formulario dividido a su vez en pestañas
\comillas{Ataque} y \comillas{Bloqueo}. Como su nombre indica, la pestaña \comillas{Ataque} sirve
para definir cómo se comportará el arma al lanzar ataques, mientras que en
la pestaña \comillas{Bloqueo} se puede definir su comportamiento al bloquear con
ella.

A continuación se explica brevemente lo que significa cada campo del formulario
de \comillas{Ataque}:

\begin{itemize}
\item {Uso mínimo: número entero que representa el valor mínimo de habilidad
con el arma que debe de tener el personaje para ser capaz de usarla con un
mínimo de éxito. Un arma con un valor de \comillas{uso mínimo} de cero puede
utilizarla cualquier personaje o criatura que pueda blandirla (otra cosa es
que la utilice bien o falle la mayoría de los ataques). Un arma con un valor
de \comillas{uso mínimo} mayor que cero no podrá ser usada en absoluto por
personajes cuya habilidad con el arma sea menor que ese valor (véase más
abajo para saber a qué nos referimos exactamente al decir \comillas{habilidad con el
arma}).}
\item {Pendiente de probabilidad: valor numérico (tipo double, es decir,
con decimales) que define la dificultad de la curva de aprendizaje de usar
el arma con éxito, es decir, lo rápido o lento que se aprende a lanzar
ataques certeros. Un valor de $0$ correspondería a una dificultad media o
moderada, valores positivos hacen el aprendizaje más fácil, y negativos más
difícil. Más abajo se explicará con más detalle cómo funcionan estos
valores; pero si no quieres complicarte, puedes poner siempre $0$, o usar
siempre los valores $-1$, $0$ y $1$ para difícil/normal/fácil.}
\item {Tiempo de ataque base: número entero que indica el tiempo (expresado
en unidades de tiempo) que tardará en lanzar un ataque alguien que tiene
justo el nivel de habilidad mínimo para utilizar el arma.}
\item {Pendiente del tiempo de ataque: valor numérico (tipo double) que
define la dificultad de la curva de aprendizaje del arma en cuanto a tiempo,
es decir, lo rápido o lento que se aprende a utilizarla para atacar con más
rapidez a medida que se va usando. De nuevo, $0$ es el valor normal, valores
positivos significan fácil y negativos difícil.}
\item {Tiempo de recuperación en ataque (base y pendiente): como los
anteriores, pero afectando al tiempo que se tarda en recuperarse de un
ataque con el arma (reposicionar el arma después de lanzar una estocada o
golpe).}
\item {Daño de ataque (tipo de daño y fórmula): tipo de daño que inflige el
arma (por ejemplo daño de golpe, cortante, de fuego, etc.) y fórmula que se
utiliza para calcular el daño.

El tipo de daño puede ser cualquier cadena que nosotros usemos en el juego
para identificar una forma de hacer daño, y su propósito es que podamos
hacer que distintas armas o armaduras sean mejores o peores para defenderse
de diferentes tipos de ataque (por ejemplo, un traje ignífugo puede ser muy
bueno para defenderse del daño de fuego hecho con un lanzallamas, pero muy
malo para defenderse del daño físico hecho por una maza). Si no queremos
llegar a este nivel de detalle en el modelado sino que queremos tratar todo
el daño de la misma manera, simplemente podemos poner la misma cadena en el
campo \comillas{tipo de daño} de todas las armas y armaduras.

La fórmula se utiliza para determinar cuánto daño de cada tipo se hace, y es
una cadena de sumas y restas cuyos términos pueden contener:

	\begin{itemize}
  \item {Un número entero, por ejemplo, 16.}
  \item {Una cantidad multiplicada por un atributo que puede ser FUE, CON,
	INT, SAB, DES, CHA o POD (fuerza, constitución, inteligencia, sabiduría,
	destreza, carisma o poder), por ejemplo, 2FUE.\footnote{Esto es poco
	genérico, porque AGE permite definir los atributos que se quiera pero sólo
	permite incluir estos atributos específicos en las fórmulas de daño. Es
	algo a mejorar en versiones futuras de AGE.}}
  \item {Una tirada de dados, formada por dos números separados por una
	letra D. Por ejemplo, 4D6 significa \comillas{tirar cuatro dados de seis caras y
	sumar su valor}. Esto añade un factor aleatorio al daño.}
	\end{itemize}

Así, por ejemplo, una fórmula de daño válida podría ser: 6+2D4+2FUE,
significando \comillas{seis, más dos dados de cuatro, más dos veces la fuerza del
personaje}.}
\item {Habilidades: conjunto de habilidades que condicionan lo bien que un
personaje utilizará el arma, lo que antes denominábamos \comillas{habilidad con el
arma}. El \comillas{valor} en este caso es tipo double e indica en qué medida
influye cada una de las habilidades, de forma que la habilidad de un
personaje para usar el arma será la suma del producto de la puntuación que
tiene en cada una de estas habilidades por el campo \comillas{valor}.

Así, a modo de ejemplo, supongamos que tenemos una espada de dos manos, y en
el formulario \comillas{Habilidades} de la pestaña \comillas{Ataque} de la pestaña \comillas{Arma}
de esa espada hemos puesto: \comillas{espadas}, con un valor de 2.0, y \comillas{armas de
dos manos}, con un valor de 1.0. Esto tiene las siguientes consecuencias:

	\begin{itemize}
  \item {La habilidad del personaje para manejar esa espada se calcula
	sumando dos veces su habilidad en \comillas{espadas} y una vez su habilidad en
	\comillas{armas de dos manos}. Por ejemplo, si el personaje tiene una habilidad
	en espadas de 100, y una habilidad en armas de dos manos de 50, su
	habilidad para manejar esta espada en particular sería 250 (pero otras
	espadas podrían requerir una combinación distinta de habilidades). Esta
	cantidad de 250 es la que se utiliza para determinar si el personaje llega
	al uso mínimo para poder utilizar esa espada, y además para calcular
	(según los valores de \comillas{base} y \comillas{pendiente} comentados) la probabilidad
	de éxito de los ataques con la espada y los tiempos de ataque y
	recuperación.}
  \item {Cada vez que el personaje lance un ataque con la espada, su
	habilidad con \comillas{espadas} se incrementará en 2, y su habilidad con \comillas{armas
	de dos manos} se incrementará en 1. Nótese que, por lo tanto, en AGE el
	valor de las habilidades de combate es un contador de uso que crece
	linealmente (si usas la espada el doble de veces, tendrás el doble de
	habilidad). Por supuesto, esto no quiere decir que la probabilidad de
	éxito al usar la espada o el tiempo de ataque evolucionen linealmente, ya
	que eso no sería realista. A continuación veremos con más detalle cómo
	evolucionan, para los interesados en las matemáticas del combate.}
	\end{itemize}}
\end{itemize}

El formulario de bloqueo permite definir los mismos valores que el de
ataque, sólo que referidos a la acción de bloquear con el arma. Así, el
\comillas{uso mínimo} y la \comillas{pendiente de probabilidad} del bloqueo determinarán
la probabilidad de bloquear con éxito. El \comillas{tiempo de bloqueo} y \comillas{tiempo
de recuperación del bloqueo} definen el tiempo que se tarda en preparar un
bloqueo y en volver a tomar la iniciativa tras llevarlo a cabo. El \comillas{daño
bloqueado} nos permite especificar fórmulas para el daño que absorbemos con
el bloqueo (que se resta al del ataque que nos hayan hecho, quedando en cero
si el daño absorbido es mayor que el daño que ha hecho el ataque). Por
último, el formulario de \comillas{habilidades} nos permite definir qué habilidades
son relevantes para (y se entrenan al) bloquear con el arma, que podrían o
no ser las mismas que las correspondientes al ataque.

\subsection{Matemática de las armas} \label{sec:MatematicaArmas}

Si bien con lo dicho en la sección anterior es suficiente para definir armas
que se puedan usar en aventuras con combates, sin duda algunos usuarios
estarán interesados en los detalles de las fórmulas matemáticas que AGE
utiliza para calcular tiempos de acciones de combate y probabilidades de
éxito.

Como se ha dicho anteriormente, se supone que el valor de una habilidad es
una estimación lineal del tiempo de experiencia que tiene el personaje
utilizando esa habilidad. Para obtener estimaciones realistas de tiempos y
probabilidades de éxito de ataques a partir de ese valor, necesitaremos
aplicar una función creciente pero de derivada negativa, de acuerdo con el
concepto intuitivo de \comillas{ganancias decrecientes} que tenemos en la vida
real: inicialmente el aprendizaje de una nueva habilidad suele ser muy
rápido; pero con el tiempo el perfeccionamiento es mucho más lento y
laborioso.

La fórmula que utiliza AGE para esto en el caso de los tiempos de ataque,
bloqueo y otras acciones de combate es la siguiente:

\begin{equation}
tiempo = \frac {tiempobase} {{(\frac {habilidad - uso~minimo} {100} + 1)}^{e^{pendiente}}}
\end{equation}

que, para hacerse una idea, tiene la forma que se ve en la figura
\ref{fig:armas1} (para tiempos base de 25 y 50, y pendientes de -1, 0 y 1).

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth]{imagenes/armas1.png}
\caption[Relación tiempo ataque y Habilidad]{Relación entre el tiempo de
ataque/bloqueo y la habilidad con el arma menos el uso mínimo.} \label{fig:armas1}
\end{figure}

Como vemos, el jugador no tardará en cogerle el truco al arma y reducir
significativamente el tiempo que le lleva usarla, pero más adelante el
aprendizaje irá siendo cada vez más paulatino.

Sin embargo, esa fórmula no lo es todo: para introducir un cierto grado de
variabilidad e incertidumbre en el combate, al tiempo obtenido de la fórmula
se le aplica cada vez una variación aleatoria, sacada de una distribución
gaussiana de media 0 y desviación típica 1/3 t, siendo t el tiempo obtenido
de la fórmula. Con lo cual, el realidad, el comportamiento tendría más bien
este aspecto que muestra la figura \ref{fig:armas4}.

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth]{imagenes/armas4.png}
\caption[Relación tiempo ataque y Habilidad (real)]{Relación entre el tiempo
de ataque/bloqueo y la habilidad con el arma menos el uso mínimo con factores
aleatorios.} \label{fig:armas4}
\end{figure}

Como podemos ver, la incertidumbre que añade la variación gaussiana hace
que, aunque los combatientes experimentados de un arma ataquen más rápido en
general, puede haber casos en los que por una cuestión de suerte un novato
consiga un ataque más rápido que un veterano. Esto añade imprevisibilidad al
combate.

Para la probabilidad de éxito de los ataques y bloqueos se utiliza una
fórmula basada en el mismo principio, que es:

\begin{equation}
probabilidad = 1 - \frac {1} {{(\frac {habilidad - uso~minimo} {100} + 1)}^{e^{pendiente}}}
\end{equation}

Dándonos unas gráficas como las de la figura \ref{fig:armas2} (para
pendientes de $-1$, $-0.5$, $0$, $0.5$ y $1$).

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth]{imagenes/armas2.png}
\caption[Probabilidad de éxito en el combate]{Probabilidad de éxito en el
combate con armas.} \label{fig:armas2}
\end{figure}

Como vemos, la probabilidad tiende rápidamente a $1$ (tener éxito siempre)
en el caso de pendiente $1$, pero no tan rápido con pendientes más
difíciles.

En el caso de la probabilidad, ya que ella misma funciona como factor para
añadir aleatoriedad e incertidumbre, no añadimos ninguna variación
gaussiana.

\subsection {Esquivadas}

Con lo visto en la sección sobre armas, ya sabemos cómo se calculan las
probabilidades de éxito y tiempos de realización de ataques y bloqueos; pero
no hemos visto cómo se calculan estos parámetros para las esquivadas.

Por el momento, la implementación de las esquivadas en AGE aún no está muy
perfeccionada, así que es sencillo: la probabilidad de realizar una
esquivada con éxito es siempre del 20\%, y esquivar consume siempre 15
unidades de tiempo.

En futuras versiones, es posible que esto se complique un poco más.

\subsection {Armaduras}

Las armaduras no son más que prendas que tienen la capacidad especial de
reducir el daño que quien las viste recibe de ataques dirigidos al miembro
donde las lleva.

Para crear una armadura en PUCK, no tenemos más que hacer lo siguiente:

\begin{itemize}
\item {Crear una prenda, tal como hemos visto anteriormente en la sección
sobre prendas.}
\item {En la pestaña \comillas{Prenda}, cubrir el formulario etiquetado como
\comillas{Valor de protección}. Este formulario funciona exactamente igual que
aquéllos en los que introducimos las fórmulas de daño de las armas, es
decir: tendremos que poner tipos de daño de los que nos protegerá la
armadura, y fórmulas para calcular cuánto daño absorberá, en el mismo
formato que en el caso de las armas (por ejemplo, 2+2D6).}
\end{itemize}

Una armadura entra en acción cuando un ataque impacta en el miembro donde el
personaje la lleva. Si bien en AGE no existen por defecto comandos
específicos para atacar a un miembro dado (\comillas{golpea a Fulano en la cabeza},
etc.); se supone que cada ataque se dirige a un miembro determinado. Este
miembro se escoge de forma aleatoria, pero de modo que la probabilidad de
elegir cada uno de los miembros de un personaje es proporcional al volumen
del miembro. Se pueden definir miembros de volumen $0$ si se quiere que
nunca reciban ataques (por ejemplo, si queremos poder llevar un anillo en el
dedo, pero que nunca nos lancen un ataque al dedo, cosa que sonaría bastante
rara).

Esto quiere decir que, por ejemplo, si en un personaje definimos los
miembros \comillas{cabeza} con volumen $10$, \comillas{cuerpo} con volumen $15$, \comillas{brazo
izquierdo} con volumen $5$ y \comillas{brazo derecho} con volumen $5$, entonces de
cada $35$ ataques que reciba el personaje irán como promedio $10$ dirigidos
a la cabeza, $15$ dirigidos al cuerpo, $5$ al brazo izquierdo y $5$ al brazo
derecho. Si ese personaje lleva un casco puesto en la cabeza, ese casco le
protegerá de esa proporción de ataques que van dirigidos a la cabeza.

La reducción de daño otorgada por una armadura se añade a la reducción
otorgada por el bloqueo, si el personaje ha bloqueado.

\subsection{Entrando en combate} \label{sec:entrando_en_combate}

Ahora que sabemos cómo funciona exactamente el combate, vamos a ver cómo
podemos utilizarlo, es decir, cómo hacemos que un personaje de un juego en
AGE luche contra malvados monstruos.

Cuando esté en la misma habitación que otra criatura, un personaje jugador
siempre puede poner el comando \textsf{atacar criatura} para lanzar un
ataque. Por defecto, las criaturas de AGE están hechas de manera que, si
tienen medios para defenderse (algún arma), siempre entrarán en combate si
las atacan, lanzando ataques, bloqueando o esquivando según consideren
oportuno.

Nótese que las órdenes por defecto para bloquear y esquivar son
\textsf{bloquear criatura y esquivar} (no hace falta especificar una
criatura concreta para esquivar, porque se supone que nos apartamos de
cualquier ataque que nos estén lanzando en ese momento).

Si queremos que sea una criatura no jugadora la que empiece la pelea,
podemos hacerlo agregándole enemigos. Toda criatura en AGE tiene una lista
de enemigos con los que entrará en combate si los ve. Podemos manipular esta
lista mediante los siguientes métodos:

\begin{lstlisting}
/*clase Mobile*/ void addEnemy ( Mobile nuevo )
\end{lstlisting}

Añade a \textsf{nuevo} como enemigo del \textsf{Mobile} sobre el que
invocamos este método.

\begin{lstlisting}
/*clase Mobile*/ boolean removeEnemy ( Mobile viejo )
\end{lstlisting}

Quita \textsf{viejo} de la lista de enemigos del \textsf{Mobile} sobre el
que invocamos este método y devuelve \textsf{true}, si estaba en la lista.
En caso de que no estuviese en la lista, este método no hace nada y devuelve
\textsf{false}.

Así, por ejemplo, si tenemos un orco y hacemos

\begin{lstlisting}
mobile("orco").addEnemy(mobile("manolo"));
\end{lstlisting}

el orco atacará automáticamente a Manolo cuando éste aparezca en su
localidad.

Por supuesto, utilizando los métodos asociados a las criaturas y los métodos
update en conjunto con la propiedad \comillas{state}, es posible definir
comportamientos más complejos de los monstruos, como que persigan a su
enemigo o patrullen una zona buscándolo.

\section {Entidades abstractas}

En las secciones preliminares de esta documentación, hemos visto que los
objetos del mundo que aparecen representados en el mapa de PUCK
(habitaciones, cosas, etc.) se denominan \textit{entidades}. Las entidades
son objetos de una clase llamada \textsf{Entity}, que tiene diferentes
subclases (como \textsf{Room}, \textsf{Mobile} o \textsf{Item}) para
representar entidades de distintas características y que juegan diferentes
papeles en el mundo.

Sin embargo, todas estas entidades tienen unas características en común
(que son precisamente lo que hace que sean entidades). Estas
características han ido apareciendo poco a poco a lo largo de esta
documentación; pero nunca las hemos listado explícitamente. Son las
siguientes:

\begin{enumerate}
\item {Toda entidad tiene un nombre único, que no puede coincidir con el de
ninguna otra entidad. Podemos obtener una entidad del mundo a partir de su
nombre único con \textsf{entity("nombre único")} (aunque las entidades de
cada clase también se puedan obtener llamando a una una función específica,
como en \textsf{item("mesa")} o \textsf{mobile("orco")}).}
\item {Toda entidad puede tener definido código BeanShell.}
\item {Toda entidad puede tener propiedades (con un valor y un temporizador)
y relaciones con cualquier otra entidad (también con un valor y un
temporizador). El sistema AGE decrementa los temporizadores de cada
propiedad cada vez que pasa una unidad de tiempo, y cuando uno de estos
temporizadores llega a cero, llama a un método de actualización (\textsf{update}) si
lo hemos definido en BeanShell, que podemos usar para definir lo que sucede
al \comillas{expirar} la propiedad.}
\end{enumerate}

Hasta ahora, hemos utilizado todas estas características en entidades como
las habitaciones, cosas o criaturas; que además representan objetos
\comillas{palpables} en el mundo con los que se puede interactuar. Pero en
ocasiones, nos puede interesar tener un objeto que también soporte estas
características (código BeanShell, propiedades, relaciones y temporizadores)
pero que no represente ningún objeto concreto o \comillas{palpable} del mundo. Ésta
es la función que tienen en AGE las entidades abstractas.

Una entidad abstracta es un objeto de la clase \textsf{AbstractEntity}, la
cual, al igual que \textsf{Room} o \textsf{Item}, es una subclase de la
clase \textsf{Entity}. Podemos agregar entidades abstractas al mapa desde
PUCK mediante el botón \comillas{Añadir entidad abstracta}, estas entidades tienen
un icono y se pueden colocar en el mapa como el resto, y también cuentan
con formularios en PUCK al igual que el resto. Sin embargo, el formulario
de una entidad abstracta es más sencillo que el de otros tipos de entidad,
ya que permite introducir poco más que nombre único, código BeanShell y
propiedades.

Así, funcionalmente una entidad abstracta no es más que un contenedor de
código BeanShell, propiedades y relaciones; que nos proporciona toda la
funcionalidad que nos dan estas características de AGE sin necesidad de
traducirse en un objeto concreto y material del mundo que se simula. Sin
embargo, como través del código BeanShell de una entidad abstracta podemos
referirnos a otras entidades y llamar a métodos que las afecten, una
entidad abstracta puede implementar comportamientos que tengan efectos
visibles en el mundo.

Algunos ejemplos de comportamientos que se han implementado con entidades
abstractas son los siguientes:

\begin {enumerate}
\item {Una entidad abstracta \comillas{tiempo atmosférico} que controle cómo va
cambiando el tiempo en las distintas habitaciones del mundo, propagando los
cambios de unas a otras mediante cambios de una propiedad en esas
habitaciones. Esos cambios de tiempo atmosférico se reflejan en las
correspondientes descripciones dinámicas.}
\item {Una entidad abstracta \comillas{incendio} que haga que las llamas de un
incendio se vayan propagando por las habitaciones, esto se utilizó en la
aventura \comillas{Fuego}.}
\item {Una entidad abstracta \comillas{guión} que haga que ciertos eventos de una
historia vayan sucediendo en momentos prefijados en distintas partes del
mundo, esto se utilizó en la aventura \comillas{15 meses y un día}.}
\end{enumerate}

Éstos son sólo ejemplos; pero los comportamientos que se pueden implementar
con entidades abstractas sólo están limitados por el ingenio del
programador.

% Sección Hechizos
\include{hechizos}

\section {Mensajes por defecto}

Muchos de los textos que una aventura de AGE muestra al jugador son textos
que el autor del juego no necesita escribir explícitamente, porque ya están
programados en el AGE. Éstos son lo que llamamos mensajes por defecto. Por
ejemplo, en la siguiente interacción:

\begin{verbatim}
> coger el asdfasdf
¿Qué pretendes coger?
> inventario
No tienes nada.
> coger la piedra
Coges la piedra.
\end{verbatim}

Los tres mensajes que muestra como salida el AGE son mensajes por defecto.
En el caso de los dos primeros, todo el texto que se muestra (\comillas{¿Qué
pretendes coger?} y \comillas{No tienes nada.}) es texto puesto por el sistema
sin necesidad de que el jugador lo especifique en ninguna parte. En el
tercer caso, el texto \comillas{Coges} proviene asimismo del sistema, mientras que
el sintagma \comillas{la piedra} se genera dinámicamente porque le hemos dado a
esa entidad el nombre para mostrar \comillas{piedra} y el género femenino que
implica el artículo \comillas{la}.

\subsection {Cambiar los mensajes por defecto}

En ciertos mundos puede resultar conveniente cambiar los mensajes por
defecto, si es que los que vienen de base con el AGE no nos gustan por
algún motivo. Por ejemplo, en un juego de ambientación medieval podríamos
querer que el sistema se dirigiera al jugador con un tratamiento más
arcaico: \comillas{¿Qué pretende coger vuesa merced?} o \comillas{Cogéis la piedra.} Por
supuesto, el AGE proporciona la posibilidad de hacer esto, para lo cual
existen varias maneras.

En primer lugar, observemos el fichero \comillas{lang/messages.lan} que está dentro
de \comillas{AgeCore.jar} (este fichero .jar se puede abrir como si fuera un .zip
para ver dicho fichero .lan). En él, podemos ver entradas como:

\begin{verbatim}
#Cuando intentas coger algo que no está en la habitación
get.what=¿Qué pretendes coger?\n
#Mostrar inventario (vacío)
you.have.nothing=No tienes nada.\n
#Cuando coges el objeto $item
you.get.item=Coges $item.\n
\end{verbatim}

Estas entradas describen mensajes por defecto de AGE, en concreto, los
vistos en el ejemplo anterior. La línea que empieza con \verb|#| en cada
entrada es simplemente un comentario que explica de qué trata el mensaje.
El texto anterior al signo \comillas{$=$} en cada línea sin comentario es el
nombre que identifica ese mensaje por defecto. Lo que hay a la derecha del
signo \comillas{$=$} es el mensaje en sí, donde los identificadores que tienen el
símbolo del dólar se van a sustituir por nombres de entidades (normalmente
debería ser obvio por el contexto cuáles: por ejemplo, en el último de los
mensajes de ejemplo, el identificador \verb|$item| se sustituye por el
nombre de la cosa que el jugador esté cogiendo, con su artículo
correspondiente).

Si cambiásemos los mensajes de este fichero, estaríamos modificando los
mensajes por defecto de AGE. Pero no es esto lo que queremos hacer, sino
modificarlos para un mundo en particular. Sin embargo, abrir el fichero
\comillas{messages.lan} es útil para esta tarea porque para cambiar mensajes para
un mundo concreto necesitaremos saber el nombre de los mensajes que
queremos redefinir (lo que viene antes del signo $=$, como
\textsf{you.get.item}) así como los parámetros que soportan (en este caso,
\verb|$item|). Sabido esto, existen dos maneras de cambiar los mensajes:

\subsubsection {Cambiar mensaje por mensaje}

Para cambiar un mensaje individual, por ejemplo, si quisiéramos que el
parser nos tratara de \comillas{vos} al coger una cosa, hacemos lo siguiente:

\begin{lstlisting}
world.getMessages().setMessage( "you.get.item" , "Cogéis $item" );
\end{lstlisting}

El método \textsf{getMessages()} de la clase \textsf{World} nos proporciona
un objeto de la clase \textsf{Messages} que encapsula los mensajes por
defecto, y el método \textsf{setMessage} nos permite cambiar cada uno de
ellos.

Este cambio de mensaje será permanente, es decir, a partir de la llamada a
este método se imprimirá \comillas{Cogéis ...} cada vez que un jugador coja una
cosa. Sin embargo, en ocasiones también querremos que se imprima un mensaje
por defecto en particular sólo en una ocasión. Para ello, también existe la
posibilidad de cambiar el mensaje sólo para la próxima vez que se imprima.
Así, si por ejemplo quisiéramos que al coger un cubito de hielo se nos
mostrara un mensaje diciendo que está frío, podríamos poner en el código
para la orden \comillas{coger} sobre el cubito se hiciese algo como:

\begin{lstlisting}
world.getMessages().setNextMessage( "you.get.item" , "Coges $item. ¡Buf, qué frío está!" );
\end{lstlisting}

De esta manera conseguiríamos que se mostrase un mensaje distinto sólo al
coger el cubito; pero no con el resto de las cosas del mundo.

\subsubsection {Cambiar todos los mensajes de una sola vez}

Si queremos personalizar una aventura completa, es posible que queramos
cambiar gran parte de los mensajes por defecto, o incluso todos. En ese
caso, es más sencillo utilizar este método:

\begin{enumerate}
\item {Crear un fichero con el formato del messages.lan (por ejemplo,
haciendo una copia de éste y modificándola).}
\item {Ponerlo en el directorio del mundo.}
\item {Hacer que el mundo ejecute el siguiente código:
\begin{lstlisting}
world.loadMessages(world.getResource("nombrefichero.lan"));
\end{lstlisting}
}
\end{enumerate}

Si no se van a cambiar los mensajes a lo largo de toda la aventura, como
sería lo más común, lo normal sería ejecutar uno de estos códigos en el
método intro (ya que se ejecuta al principio). Si se quieren tener
diferentes mensajes o juegos de mensajes en distintas partes de la historia,
estos métodos se pueden ejecutar en cualquier punto de la misma para
cambiarlos a partir de ese momento (se pueden tener varios ficheros de
mensajes, o se pueden cambiar los mensajes uno por uno varias veces sin
problema).

\subsection {Generar dinámicamente los mensajes por defecto}

Si en una aventura interesa que los mensajes por defecto sean muy dinámicos
y cambiantes (por ejemplo, que cada vez que cojamos un objeto se elija un
mensaje diferente de un conjunto de alternativas de forma aleatoria, o
alguna otra cosa que requiera procesado); es posible controlar mediante
código BeanShell el mostrado del mensaje, pasando por encima tanto de los
mensajes por defecto definidos por AGE como de los establecidos para el
mundo según lo visto en la sección anterior. Para ello, en el objeto mundo,
redefinimos el método

\begin{lstlisting}
String getMessage ( String messageName , Object[] arguments )
\end{lstlisting}

donde como parámetro se nos pasa el nombre del mensaje que AGE quiere
mostrar (por ejemplo, \textsf{you.get.item}) y un array con todas las
entidades u otros objetos relevantes al mensaje (en este caso, el array
tendría longitud 1 y sólo contendría la cosa que se está cogiendo y que se
utilizaría por defecto para sustituir \verb|$item|).

El método debe devolver el mensaje que queremos que se muestre en ese caso,
o bien \textsf{null} si no queremos alterar el comportamiento para ese
mensaje y objetos sino delegar en el mecanismo por defecto de mensajes del
mundo o de AGE.

\section{Manejo de eventos}

Para simular un mundo realmente dinámico, es importante conseguir que las
entidades del mundo puedan reaccionar automáticamente ante los sucesos que
ocurren en su entorno. Por ejemplo, nos puede interesar que un hombre nos
salude al entrar en su jardín, que un puente se derrumbe al pasar por él,
que una capa vuelva invisible al personaje que se la pone, que un gnomo se
enfade si le roban su sombrero, o que un personaje nos responda cuando le
hablamos. Muchas de estas cosas se pueden conseguir con un manejo
cuidadoso de las propiedades y el método update (\ref{sec:Temporizacion}),
sobre todo en conjunción con la gestión de los estados de las criaturas
(\ref{sec:prog-estados}). Sin embargo, si bien esta forma de hacer las
cosas es muy potente, puede resultar incómoda, sobre todo si necesitamos
gestionar muchas posibles reacciones. Por ello, AGE proporciona un
mecanismo específico, más sencillo, para que los distintos componentes del
mundo puedan reaccionar a sucesos, o \textit{eventos}, que ocurren en él. Para
ello, el programador sólo tiene que definir en sus entidades los llamados
\textit{métodos de captura de eventos}, que son métodos que AGE ejecuta
automáticamente cuando sucede un evento dado.

Conviene aclarar que, a lo largo de esta sección y el resto de la 
documentación, se utilizará la palabra \comillas{evento} con dos 
sentidos diferentes: por un lado, el evento propiamente dicho (un 
suceso que desencadena una reacción), y por otro, el método de captura 
del evento (el método que ejecuta AGE, permitiendo al programador 
definir dicha reacción).

\subsection{Métodos de captura de eventos}

Como acabamos de anticipar, el método de captura de un evento (que, 
para abreviar, también llamaremos \textit{evento} a secas) es un método 
que AGE ejecuta automáticamente cuando ocurre en el mundo un suceso 
determinado. Normalmente, un evento se define en una entidad dada y se 
ejecuta como reacción a algo que sucede en el entorno de esa entidad. 

Por ejemplo, en una habitación podemos definir un evento que se active 
cuando una criatura entre en dicha habitación. Para ello, podemos ir a 
la pestaña \comillas{Código y propiedades} de dicha habitación, 
agrandar el campo de código y, en el menú contextual (botón derecho), 
seleccionar \comillas{Insertar código - Definir eventos de habitación}. 
Al hacer esto, veremos en el menú desplegable los distintos eventos de 
habitación que están disponibles, y podremos seleccionar el que nos 
interesa, en este caso \comillas{Al entrar en la habitación}, que nos 
genera una plantilla como sigue:

\begin{lstlisting}
/*
Método que captura el evento lanzado cuando una criatura entra en una habitación.
*/
void onEnterRoom ( Mobile aCreature )
{

    //aCreature: criatura que entra en la habitación.
    //self: habitación en la que entra (es decir, esta habitación).

}
\end{lstlisting}

Tal y como explican los comentarios de la plantilla, el método (que 
llamamos evento \textsf{onEnterRoom}) sólo recibe un parámetro: un 
\textsf{Mobile} que representa la criatura que ha entrado en la habitación. 
Así, cada vez que alguien entre, AGE va a ejecutar automáticamente el 
evento, pasándonos como parámetro el personaje que ha entrado por si 
necesitamos hacer algo con él (como hacerle caer en una trampa). Por 
supuesto, somos libres de no utilizar el parámetro si no queremos 
interactuar con la criatura en cuestión (tal vez queremos que cuando 
alguien entre en la habitación suceda algo que no involucre 
directamente a ese personaje, como que suene una alarma).

A modo de ejemplo, supongamos que nuestra habitación es una tienda de 
alfombras, atendida en todo momento por Manolo, el esforzado tendero, 
que tiene como nombre único \comillas{manolo}. Podemos hacer que nos 
salude y nos ofrezca su selecta mercancía cada vez que entremos, de la 
siguiente manera:

\begin{lstlisting}
/*
Método que captura el evento lanzado cuando una criatura entra en una habitación.
*/
void onEnterRoom ( Mobile aCreature )
{

    //aCreature: criatura que entra en la habitación.
    //self: habitación en la que entra (es decir, esta habitación).
    mobile("manolo").say("¡Bienvenido, oh, potencial cliente!"); 
    mobile("manolo").say("Tengo las mejores alfombras al oeste del Pecos, a unos precios de escándalo.");

}
\end{lstlisting}

Con este código, el tendero dará su saludo a cualquier personaje o 
criatura que entre en la tienda. Nótese que sólo tiene sentido si 
Manolo está siempre en su tienda: si puede estar en otro sitio, 
tendríamos que comprobar primero que realmente está presente:

\begin{lstlisting}
/*
Método que captura el evento lanzado cuando una criatura entra en una habitación.
*/
void onEnterRoom ( Mobile aCreature )
{

    //aCreature: criatura que entra en la habitación.
    //self: habitación en la que entra (es decir, esta habitación).
    Mobile tendero = mobile("manolo");
    if ( self.hasMobile( tendero ) )
    {
        tendero.say("¡Bienvenido, oh, potencial cliente!"); 
        tendero.say("Tengo las mejores alfombras al oeste del Pecos, a unos precios de escándalo.");
    }

}
\end{lstlisting}

Si bien en este ejemplo no se utiliza el parámetro de entrada del 
método, puede haber ocasiones en las que sea necesario. Por ejemplo, 
imaginemos que a Manolo no le gustan los perros, y no los admite en su 
tienda. Entonces, su reacción tendrá que ser diferente según si la 
criatura que entra es un ser humano o un perro. Suponiendo que en 
nuestra aventura tenemos una propiedad \comillas{esperro} que 
identifica a los perros, podríamos hacer algo como lo siguiente:

\begin{lstlisting}
/*
Método que captura el evento lanzado cuando una criatura entra en una habitación.
*/
void onEnterRoom ( Mobile aCreature )
{

    //aCreature: criatura que entra en la habitación.
    //self: habitación en la que entra (es decir, esta habitación).
    Mobile tendero = mobile("manolo");
    if ( self.hasMobile( tendero ) )
    {
        if ( get( aCreature,"esPerro" ) )
        {
            tendero.say("¡Vade retro, sucio cánido! Los de tu especie no son bienvenidos aquí.");
        }
        else
        {
            tendero.say("¡Bienvenido, oh, potencial cliente!"); 
            tendero.say("Tengo las mejores alfombras al oeste del Pecos, a unos precios de escándalo.");
        }
    }

}
\end{lstlisting}

De la misma manera que reaccionamos a la entrada de una criatura en una 
habitación, existen otros eventos que podemos definir tanto en 
habitaciones como en criaturas y cosas para reaccionar ante otros 
muchos sucesos que pueden producirse en el mundo. Para utilizar un 
evento, sólo hay que saber su nombre, cuándo se ejecuta y qué parámetro 
o parámetros necesita (o simplemente buscarlo en el menú contextual de 
PUCK y mirar la plantilla). Puedes consultar la documentación de todos 
los eventos, con una breve explicación de cómo se utiliza cada uno, en 
la lista de eventos (\ref{sec:eventos}).

Sin embargo, un aspecto concreto que se puede implementar con eventos 
es lo suficientemente importante como para dedicarle su propio 
epígrafe: la implementación de conversaciones con personajes.

\subsection{Conversaciones}

Una particularidad muy característica de los juegos de texto es la 
posibilidad de que haya personajes en el mundo que conversen 
automáticamente con los jugadores. Esto se puede implementar de maneras 
muy diferentes, como pueden ser los menús o árboles de conversación, la 
conversación por temas seleccionables, o la conversación libre.

El sistema AGE está diseñado para dar soporte sencillo a la 
conversación libre, es decir, aquélla donde un jugador o personaje 
puede decir cualquier cosa (sin estar restringido a seleccionar 
posibilidades de un menú, o a una estructura fija de pregunta). Si bien 
otros modos de conversación (como puede ser por menús) se pueden 
implementar, no se proporcionan herramientas para ellos por defecto, al 
menos por el momento, teniendo que programar los menús el creador de la 
aventura. Sin embargo, AGE sí que tiene un sistema pensado para 
facilitar la conversación libre. Dicho sistema funciona de la siguiente 
manera:

\begin{itemize}
  \item {En cualquier momento, un jugador o personaje puede decir algo. 
  En el caso de los jugadores, esto sucede normalmente como 
  consecuencia de una orden: por defecto, si un jugador teclea 
  \comillas{decir ''hola''} el resultado será que su personaje dice 
  \comillas{hola}. En el caso de los personajes no jugadores, podemos 
  hacer que digan algo llamando a \textsf{personaje.say(''hola'')}.}

  \item{Cuando un personaje dice algo, se envía una notificación a la 
  habitación que contiene el texto que ha dicho. Esto tiene como 
  consecuencia que se muestra un mensaje a los personajes que estén 
  allí, para informar de lo que ha pasado (por defecto, se mostrará 
  \textsf{Dices ''hola''.} si lo has dicho tú, o \textsf{Fulanito dice 
  ''hola''.}, si es otro personaje el que ha hablado).

\begin{verbatim}
> decir "hola"
Dices "hola".
\end{verbatim}
}

  \item {El hecho de que alguien haya hablado en la habitación actual 
  se puede capturar mediante un evento \textsf{onSay}, que toma como 
  parámetros el personaje que ha hablado y el texto que ha dicho.}

\end{itemize}

Sabiendo esto, podemos programar personajes que conversen libremente a 
base de definir su evento \textsf{onSay}. Para acceder a la plantilla 
de este evento, basta con ir al menú contextual en el panel de código 
del personaje, y seleccionar \comillas{Insertar código - Definir 
eventos de personaje - Al oír a alguien decir algo}. Entonces, 
aparecerá la siguiente plantilla:

\begin{lstlisting}
//evento que se ejecuta cuando alguien dice algo en la habitación
//en la que está este personaje

//subject: personaje que ha hablado
//text: lo que ha dicho

void onSay( Mobile subject , String text )
{

}
\end{lstlisting}

Supongamos que queremos mejorar a Manolo, el vendedor, para que sea 
capaz de responder a algunas preguntas de sus clientes. Para ello, 
definiremos este evento en el código de Manolo. Cada vez que alguien 
diga algo en su tienda, se invocará el método \textsf{onSay}, con el 
parámetro \textsf{subject} indicando quién ha hablado (esto no incluye al 
propio Manolo) y el parámetro \textsf{text}, que es una cadena, conteniendo 
lo que ha dicho.

Para implementar la conversación, tendremos que analizar el contenido 
de la cadena \textsf{text}, mirando si podemos reconocer todo o parte 
de lo que dice. Para ello, podemos hacer uso de la rica funcionalidad 
de cadenas que nos proporciona Java, incluyendo todo tipo de métodos de 
comparación y de reconocimiento de patrones con expresiones regulares.

Empecemos haciendo que responda si le dicen \comillas{hola}. La forma 
más elemental de hacerlo sería añadir esto al evento:

\begin{lstlisting}
if ( equals ( text , "hola" ) )
    self.say("Y hola a ti también, apreciado cliente");
\end{lstlisting}

Efectivamente, con esto conseguiremos que el tendero responda a ese 
saludo:

\begin{verbatim}
> decir "hola"
Dices "hola".
Manolo dice "Y hola a ti también, apreciado cliente".
\end{verbatim}

Sin embargo, esta implementación no es muy flexible, porque sólo 
responderá si le dicen exactamente \comillas{hola}, y no si le dicen, 
por ejemplo, \comillas{hola Manolo}. Podemos flexibilizarla haciendo 
algo como:

\begin{lstlisting}
if ( text.toLowerCase().startsWith("hola") )
    self.say("Y hola a ti también, apreciado cliente");
\end{lstlisting}

\textsf{startsWith} es un método de Java que nos dice si nuestra cadena 
empieza por el parámetro que se le pasa, en este caso \comillas{hola}. 
El método \textsf{toLowerCase()} es una función de paso del texto a 
minúsculas, que es necesaria aquí porque los métodos de manejo de 
cadenas de Java (como \textsf{startsWith}), a diferencia de las 
funciones que vienen con AGE, son sensibles a mayúsculas y minúsculas. 
Por lo tanto, es conveniente pasar la cadena \textsf{text} a minúsculas 
antes de usar estos métodos sobre ella, al menos si queremos que Manolo 
sea capaz de entender tanto \comillas{hola} como \comillas{Hola} u 
\comillas{HOLA}. En la práctica, sobre todo si vamos a tener un evento 
\textsf{onSay} largo, lo más cómodo probablemente sea hacer esto al 
principio del evento, y luego desentendernos:

\begin{lstlisting}
//evento que se ejecuta cuando alguien dice algo en la habitación
//en la que está este personaje

//subject: personaje que ha hablado
//text: lo que ha dicho

void onSay( Mobile subject , String text )
{
    text = text.toLowerCase(); //a partir de aquí, sabemos que text ya está en minúsculas
    if ( text.startsWith("hola") )
        self.say("Y hola a ti también, apreciado cliente");
}
\end{lstlisting}

Si en lugar de comprobar por qué empieza lo que se ha dicho en la 
habitación preferimos saber si contiene (no necesariamente al 
principio) una cadena dada, podemos utilizar otro método de las cadenas 
Java, en este caso \textsf{contains}. Por ejemplo, podemos hacer que 
Manolo reaccione cuando se le menciona un perro en cualquier posición 
dentro de una oración:

\begin{lstlisting}
//evento que se ejecuta cuando alguien dice algo en la habitación
//en la que está este personaje

//subject: personaje que ha hablado
//text: lo que ha dicho

void onSay( Mobile subject , String text )
{
    text = text.toLowerCase(); //a partir de aquí, sabemos que text ya está en minúsculas
    if ( text.startsWith("hola") )
        self.say("Y hola a ti también, apreciado cliente");
    else if ( text.contains("perr") )
        self.say("Perros. Puaj. No quiero a esas sucias criaturas cerca de mi pulcra tienda. ¡Ni las menciones!");
}
\end{lstlisting}

Como se puede ver, \textsf{contains} funciona de manera muy similar a 
\textsf{startsWith}: es un método booleano, tal que 
\textsf{a.contains(b)} devuelve \textsf{true} si la cadena \textsf{a} 
contiene en su interior a la cadena \textsf{b}, y \textsf{false} en 
caso contrario.

Con métodos como \textsf{startsWith} y \textsf{contains} se puede 
implementar, con un poco de meticulosidad y cuidado, conversaciones muy 
completas, y son una buena opción para empezar. El lector que quiera 
profundizar en las capacidades de Java para operar con cadenas también 
puede consultar la 
\href{http://docs.oracle.com/javase/6/docs/api/java/lang/String.html}{documentación 
de la clase String} de Java, donde aparecen muchos más métodos que se 
pueden utilizar con cadenas además de los que acabamos de ver. Muchos 
de ellos pueden ser de interés para implementar conversaciones más 
ricas.

Adicionalmente, el programador avanzado hará bien en consultar la 
\href{https://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html}{documentación 
de la clase Pattern}, donde se especifica cómo crear y aplicar las 
expresiones regulares. Las expresiones regulares son una notación para 
expresar patrones de cadenas que nos permiten comprobar si una cadena 
cumple una condición de forma mucho más concisa y sencilla (una vez que 
uno las conoce) que con combinaciones de operaciones como 
\textsf{contains}, \textsf{toLowerCase}, \textsf{startsWith} y demás. 
Por ejemplo, si queremos comprobar si una cadena \textsf{s} es o bien 
\comillas{perro} o bien \comillas{perra}, una manera de hacerlo sería

\begin{lstlisting}
if ( s.equals("perro") || s.equals("perra") ) ...
\end{lstlisting}

Pero con expresiones regulares, podemos hacer esto en su lugar:

\begin{lstlisting}
if ( s.matches("perr[oa]") ) ...
\end{lstlisting}

Donde \comillas{[oa]} significa que en esa posición hay o bien la letra 
\comillas{o}, o bien la letra \comillas{a}. De ese mismo modo, las 
expresiones regulares permiten expresar otras muchas cosas, no sólo 
sobre caracteres individuales sino también sobre rangos numéricos, 
alfanuméricos, límites entre palabras, etc.

Por ejemplo, si nos fijamos bien en el último código para la 
conversación con Manolo, podemos darnos cuenta de que la forma de 
detectar si el interlocutor le habla de perros no es la más adecuada. 
Estamos mirando si el texto contiene \comillas{perr}, pero esto también 
va a suceder si alguien le dice a Manolo que está \comillas{emperrado} 
en regatearle el precio de una alfombra, o que el dibujo de uno de sus 
productos es \comillas{hiperrealista}. Con expresiones regulares, 
podemos afinarlo mucho más, convirtiendo la línea en algo como:

\begin{lstlisting}
else if ( text.matches(".*\\bperr[oa]s?\\b.*") )
\end{lstlisting}

que mira si la cadena contiene las palabras \comillas{perro}, 
\comillas{perra}, \comillas{perros} o \comillas{perras}: los \verb|\\b| 
representan un límite de palabra (es decir, un carácter de espaciado, o 
bien el principio o final de la cadena), los \textsf{.*} representan 
que puede haber cualquier número de caracteres (incluyendo 0) antes o 
después de esa palabra, y la interrogación después de la letra 
\comillas{s} quiere decir que ésta es opcional.

En este documento no detallaremos toda la lista de posibles expresiones 
regulares que se pueden construir, ya que se pueden encontrar tanto en 
la documentación de Java (de la 
\href{https://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html}{clase 
Pattern} antes mencionada) como en numerosos libros y tutoriales 
online.

Con estos mimbres y lo visto en secciones anteriores de la 
documentación, se pueden construir personajes con conversaciones muy 
ricas y complejas. Por supuesto, lo que se puede hacer va mucho más 
allá de las secuencias de \textsf{if} como hemos visto en el caso de 
Manolo, ya que podemos aprovechar los estados y relaciones de AGE para 
hacer que la conversación de un personaje cambie según el contexto del 
diálogo. A modo de ejemplo, el siguiente código de conversación 
pertenece a una mujer que se encuentra el héroe de la aventura 
\comillas{Fuego} (se ha editado un poco para modernizar el código, ya 
que esa aventura se hizo en una versión antigua de AGE y de Java menos 
potente que la actual, donde conseguir algunas cosas era más 
engorroso):

\begin{lstlisting}
(...)

else if ( lText.contains("hola") || lText.contains("buenas") 
	|| lText.contains("saludo") || lText.contains("buenos d") )
	{
		//nos están saludando, saludamos de vuelta
		self.say("Hola...");
		//miramos si conocemos el nombre del interlocutor
		String nombre = get ( self , "nombre", m );
		if ( nombre == null || nombre.equals("unknown") )
		{
			//si no conocemos el nombre, se lo preguntamos. Esperamos que nos lo diga.
			self.say("¿Cómo te llamas?");
			set ( self , "esperandonombre" , m , true );
		}
	}

(...)

else
{
	//si estamos esperando nombre, asumiremos que lo que nos dice lo es.
	if ( get ( self , "esperandonombre" , m ) )
	{
		if ( !lText.matches("(\\w*\\W*){1,3}") )
		{
			//si nos dice algo con más de tres palabras, probablemente no nos esté diciendo su nombre de verdad. Se ha ido por las ramas.
			self.say("Uy, ese nombre es muy largo. Dudo que pueda recordarlo. ¿No te puedo llamar por algún nombre más corto?");	
		}
		else
		{
			//hacer que el nombre empiece por mayúscula
			if ( !Character.isUpperCase(lText.charAt(0)) )
				lText = Character.toUpperCase(lText.charAt(0)) + lText.substring(1);
			//actualizar las relaciones, reflejando que conocemos el nombre del personaje (y cuál es)
			set ( self , "nombre" , m , (String)lText );
			set ( self , "esperandonombre" , m , false );
			self.say("Encantado, " + self.getRelationshipPropertyValueAsString ( m , "nombre" ) + ". Yo soy María.");	
		}
	}	
	else
	{

(...)
\end{lstlisting}

En este ejemplo, cuando alguien saluda a María, ésta le pregunta su 
nombre. Cuando el interlocutor se lo dice, María se queda con el dato 
(almacenado en una relación con el interlocutor, llamada 
\comillas{nombre}) y lo usará a lo largo de la conversación:

\begin{verbatim}
> decir "hola"
Dices "hola".
La mujer dice "Hola...".
La mujer dice "¿Cómo te llamas?".
> decir "juan"
La mujer dice "Encantado, Juan. Yo soy María."
\end{verbatim}

De este modo, a partir de propiedades y relaciones, podemos hacer que 
las reacciones de los personajes a lo que les decimos varíen de acuerdo 
a lo que se ha dicho antes en la conversación, y por supuesto también a 
otros factores como identidad del interlocutor, humor actual del 
personaje, situación en el mundo, eventos que hayan sucedido, y un 
largo etcétera. El único límite es la imaginación y el esfuerzo 
dedicado a añadir detalle a la simulación.

